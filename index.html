<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <title>–ö–æ—Ç–æ—Å—Ç—Ä–æ—Ñ–∞: –õ–µ–≥–µ–Ω–¥—ã –°–∞–¥–∞</title>
    <style>
        /* –ü–æ–¥–∫–ª—é—á–∞–µ–º –û–î–ò–ù —Ö–æ—Ä–æ—à–∏–π, —á–∏—Ç–∞–µ–º—ã–π —à—Ä–∏—Ñ—Ç */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        :root {
            --ui-scale: 1; /* –ë–∞–∑–æ–≤—ã–π –º–∞—Å—à—Ç–∞–± –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ */
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #2d9e6d;
            /* –ò–°–ü–û–õ–¨–ó–£–ï–ú –¢–û–õ–¨–ö–û Fredoka One, –±–µ–∑ cursive */
            font-family: 'Fredoka One', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
            /* –§–∏–∫—Å –¥–ª—è iOS, —á—Ç–æ–±—ã –Ω–µ –≤—ã–¥–µ–ª—è–ª—Å—è —Ç–µ–∫—Å—Ç –ø—Ä–∏ —Ç–∞–ø–∞—Ö */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* --- –°–û–û–ë–©–ï–ù–ò–ï –û –ü–û–í–û–†–û–¢–ï –≠–ö–†–ê–ù–ê --- */
        #rotate-message {
            display: none; /* –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–∫—Ä—ã—Ç–æ */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95); color: #f1c40f;
            z-index: 9999; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px; box-sizing: border-box;
        }
        #rotate-message span { font-size: 60px; margin-bottom: 20px; animation: rotatePhone 2s infinite ease-in-out; display: inline-block; }
        @keyframes rotatePhone { 0%, 100% { transform: rotate(0deg); } 50% { transform: rotate(90deg); } }

        /* –ü–û–ö–ê–ó–´–í–ê–¢–¨ —Å–æ–æ–±—â–µ–Ω–∏–µ –¢–û–õ–¨–ö–û –Ω–∞ —É–∑–∫–∏—Ö –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã—Ö —ç–∫—Ä–∞–Ω–∞—Ö */
        @media screen and (orientation: portrait) and (max-width: 768px) {
            #rotate-message { display: flex; }
        }

        /* --- –ê–î–ê–ü–¢–ê–¶–ò–Ø –ò–ù–¢–ï–†–§–ï–ô–°–ê –î–õ–Ø –ú–û–ë–ò–õ–¨–ù–´–• --- */
        /* –ï—Å–ª–∏ —ç–∫—Ä–∞–Ω —É–∑–∫–∏–π (—Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ—Ä—Ç—Ä–µ—Ç–µ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –º–∞–ª–µ–Ω—å–∫–∏–π —ç–∫—Ä–∞–Ω) - —É–º–µ–Ω—å—à–∞–µ–º –º–∞—Å—à—Ç–∞–± UI */
        @media (max-width: 768px) {
            :root { --ui-scale: 0.75; /* –£–º–µ–Ω—å—à–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–æ 75% */ }
            
            /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —É–º–µ–Ω—å—à–∞–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–µ—à–∞—é—Ç */
            #joystick-area { width: 120px !important; height: 120px !important; bottom: 30px !important; left: 30px !important; }
            .joy-stick { width: 40px !important; height: 40px !important; }
            #minimap-container { width: 150px !important; height: 150px !important; bottom: 70px !important; /* –ü–æ–¥–Ω–∏–º–∞–µ–º –Ω–∞–¥ –¥–∂–æ–π—Å—Ç–∏–∫–æ–º –µ—Å–ª–∏ –æ–Ω–∏ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—Ç—Å—è */ }
            
            h1 { font-size: 28px !important; } /* –£–º–µ–Ω—å—à–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –≤ –º–µ–Ω—é */
            .card { width: 130px !important; padding: 10px !important; } /* –£–º–µ–Ω—å—à–∞–µ–º –∫–∞—Ä—Ç–æ—á–∫–∏ */
            .card-icon { font-size: 28px !important; }
            .card-title { font-size: 13px !important; }
        }


        /* UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            /* –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–± –∫–æ –≤—Å–µ–º—É UI */
            transform: scale(var(--ui-scale)); transform-origin: top left; width: calc(100% / var(--ui-scale)); height: calc(100% / var(--ui-scale));
        }

        /* HUD */
        .hud-top {
            position: absolute; top: 10px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
        }
        .hud-left { display: flex; flex-direction: column; gap: 5px; width: 220px; }
        .hud-center { text-align: center; pointer-events: auto; }
        
        .hud-stats {
            display: flex; gap: 15px; justify-content: center;
            background: rgba(0,0,0,0.6); padding: 5px 15px;
            border-radius: 20px; margin-top: 5px; font-size: 16px; border: 1px solid #444;
        }

        .bar-container {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px; height: 22px; width: 100%;
            overflow: hidden; position: relative;
        }
        .hp-bar { background: linear-gradient(90deg, #ff4757, #ff6b81); width: 100%; height: 100%; transition: width 0.2s; }
        .xp-bar { background: linear-gradient(90deg, #2ed573, #7bed9f); width: 0%; height: 100%; transition: width 0.2s; }
        .bar-text { position: absolute; width: 100%; text-align: center; top: 2px; font-size: 12px; text-shadow: 1px 1px 1px black; z-index: 2; }

        #game-timer { font-size: 32px; text-shadow: 0 0 10px #000; color: #f1c40f; letter-spacing: 2px; }

        /* MINIMAP */
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 200px; height: 200px;
            background: rgba(46, 204, 113, 0.3);
            border: 4px solid #fff; border-radius: 50%; overflow: hidden;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); backdrop-filter: blur(5px);
            pointer-events: auto; /* –ß—Ç–æ–±—ã –∫–∞—Ä—Ç–∞ –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞–ª–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –¥–∂–æ–π—Å—Ç–∏–∫ –ø–æ–¥ –Ω–µ–π */
        }
        #minimap { width: 100%; height: 100%; display: block; }

        /* INTRO COMIC */
        #intro-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; text-align: center; pointer-events: auto;
        }
        .slide { display: none; max-width: 600px; animation: fadeIn 1s; }
        .slide.active { display: block; }
        .slide-img { font-size: 80px; margin-bottom: 20px; }
        .slide-text { font-size: 24px; line-height: 1.5; color: #ecf0f1; margin-bottom: 30px; }
        .skip-btn { position: absolute; bottom: 20px; right: 20px; color: #7f8c8d; cursor: pointer; font-size: 14px; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(26, 26, 46, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; pointer-events: auto; padding-bottom: 40px; /* –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è –º–æ–±–∏–ª–æ–∫ */
        }

        h1 { color: #ffa502; font-size: 40px; margin: 0 0 10px 0; text-shadow: 3px 3px 0 #000; font-family: 'Fredoka One', sans-serif; }
        h2 { margin-bottom: 20px; color: #ced6e0; font-size: 18px; font-family: 'Fredoka One', sans-serif; }

        .cards-container {
            display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
            max-width: 900px; max-height: 70vh; overflow-y: auto; padding: 10px;
             /* –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–µ—Ä—Ü–∏–æ–Ω–Ω—É—é –ø—Ä–æ–∫—Ä—É—Ç–∫—É –¥–ª—è iOS */
            -webkit-overflow-scrolling: touch;
        }

        .card {
            background: #30336b; border: 3px solid #535c68; border-radius: 12px; padding: 15px; width: 160px;
            cursor: pointer; text-align: center; position: relative; transition: 0.2s;
        }
        .card:hover { transform: translateY(-5px); border-color: #f1c40f; background: #4834d4; }
        .card.rare { border-color: #e056fd; background: #2c0e3a; box-shadow: 0 0 15px #e056fd; }
        .card.mega { border-color: #ff4757; background: #5a0e16; box-shadow: 0 0 20px #ff4757; animation: pulse 1s infinite; }
        
        .card-icon { font-size: 35px; margin-bottom: 8px; display: block; }
        .card-title { font-size: 15px; color: #f1c40f; margin-bottom: 5px; font-weight: bold; }
        .card-desc { font-size: 11px; color: #dff9fb; line-height: 1.3; }
        .rare-badge { position: absolute; top: -10px; right: -10px; background: #e056fd; font-size: 10px; padding: 3px 8px; border-radius: 10px; transform: rotate(15deg); }

        .btn {
            background: #f39c12; color: #fff; border: 3px solid #fff; padding: 12px 30px; font-size: 20px; border-radius: 30px;
            cursor: pointer; font-family: inherit; margin-top: 15px; box-shadow: 0 5px 0 #d35400; transition: 0.1s;
        }
        .btn:active { transform: translateY(5px); box-shadow: 0 0 0 #d35400; }

        #joystick-area {
            position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px;
            pointer-events: auto; display: none;
        }
        .joy-base {
            width: 100%; height: 100%; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; position: relative;
        }
        .joy-stick {
            width: 50px; height: 50px; background: #f1c40f; border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        #pickup-msg {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            font-size: 28px; font-weight: bold; text-shadow: 2px 2px 4px #000;
            color: #f1c40f; opacity: 0; pointer-events: none;
        }
        
        #altar-warning {
             position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
             font-size: 24px; color: #ff4757; text-align: center; text-shadow: 2px 2px 0 #000;
             display: none; animation: flash 1s infinite;
        }
        @keyframes flash { 0% {opacity:1} 50% {opacity:0.5} 100% {opacity:1} }
    </style>
</head>
<body>

    <div id="rotate-message">
        <span>üì±üîÑ</span>
        <h1>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ!</h1>
        <p>–ò–≥—Ä–∞ –ª—É—á—à–µ –≤—Å–µ–≥–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ.</p>
    </div>

    <div id="intro-screen" style="display:none;">
        <div class="slide active" onclick="nextSlide()">
            <div class="slide-img">üåë</div>
            <div class="slide-text">–í 2025 –≥–æ–¥—É —Ç—å–º–∞ —Å–≥—É—Å—Ç–∏–ª–∞—Å—å –Ω–∞–¥ —Å—Ç–∞—Ä—ã–º —Å–∞–¥–æ–º...<br>–ü—ã–ª–µ–≤—ã–µ –ö—Ä–æ–ª–∏–∫–∏ –∏ –û–≤–æ—â–∏-–ú—É—Ç–∞–Ω—Ç—ã –≤–æ—Å—Å—Ç–∞–ª–∏.</div>
            <div class="btn">–î–∞–ª–µ–µ...</div>
        </div>
        <div class="slide" onclick="nextSlide()">
            <div class="slide-img">üêà</div>
            <div class="slide-text">–õ—é–¥–∏ —Å–ø–∞–ª–∏ –∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤–∏–¥–µ–ª–∏.<br>–ù–æ –∫–æ—Ç—ã... –ö–æ—Ç—ã –≤–∏–¥–µ–ª–∏ –≤—Å—ë.</div>
            <div class="btn">–î–∞–ª–µ–µ...</div>
        </div>
        <div class="slide" onclick="nextSlide()">
            <div class="slide-img">‚öîÔ∏è</div>
            <div class="slide-text">–í–∑—è–≤ –ª–∞–∑–µ—Ä–Ω—ã–µ —É–∫–∞–∑–∫–∏ –∏ –∫–ª—É–±–∫–∏,<br>–ø—É—à–∏—Å—Ç—ã–π –æ—Ç—Ä—è–¥ –≤—ã—à–µ–ª –Ω–∞ —Ç—Ä–æ–ø—É –≤–æ–π–Ω—ã.</div>
            <div class="btn">–í –ë–û–ô!</div>
        </div>
        <div class="skip-btn" onclick="startGameFlow()">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="display:none;">
        <div class="hud-top">
            <div class="hud-left">
                <div class="bar-container">
                    <div class="hp-bar" id="hp-bar"></div>
                    <div class="bar-text" id="hp-text">HP</div>
                </div>
                <div class="bar-container" style="border-color: #2ed573; margin-top: 5px;">
                    <div class="xp-bar" id="xp-bar"></div>
                    <div class="bar-text" id="lvl-text">LVL 1</div>
                </div>
                <div id="weapons-list" style="margin-top: 5px; display: flex; gap: 5px;"></div>
            </div>
            
            <div class="hud-center">
                <div id="game-timer">00:00</div>
                <div class="hud-stats">
                    <span id="coin-count">üí∞ 0</span>
                    <span id="kill-count">üíÄ 0</span>
                </div>
            </div>
            <div class="hud-left" style="opacity: 0; pointer-events: none;"></div>
        </div>
        
        <div id="minimap-container">
            <canvas id="minimap"></canvas>
        </div>
        
        <div id="pickup-msg"></div>
        <div id="altar-warning">–ê–õ–¢–ê–†–¨ –ó–ê–ü–ï–ß–ê–¢–ê–ù<br>–ñ–¥–∏—Ç–µ 10-–π –º–∏–Ω—É—Ç—ã...</div>

        <div id="joystick-area">
            <div class="joy-base"><div class="joy-stick" id="joy-stick"></div></div>
        </div>
    </div>

    <div id="class-screen" class="screen" style="display: none;">
        <h1>–í–´–ë–û–† –ì–ï–†–û–Ø</h1>
        <div class="cards-container">
            <div class="card" onclick="game.start('mainecoon')"><span class="card-icon">ü¶Å</span><div class="card-title">–ú–µ–π–Ω-–∫—É–Ω</div><div class="card-desc">–¢–∞–Ω–∫. –ú–Ω–æ–≥–æ HP.<br>–û—Ä—É–∂–∏–µ: –õ–∞–ø–∞</div></div>
            <div class="card" onclick="game.start('sphynx')"><span class="card-icon">üëΩ</span><div class="card-title">–°—Ñ–∏–Ω–∫—Å</div><div class="card-desc">–°–∫–æ—Ä–æ—Å—Ç—å.<br>–û—Ä—É–∂–∏–µ: –õ–∞–∑–µ—Ä</div></div>
            <div class="card" onclick="game.start('tabby')"><span class="card-icon">üòº</span><div class="card-title">–ü–æ–ª–æ—Å–∞—Ç—ã–π</div><div class="card-desc">–ë–∞–ª–∞–Ω—Å.<br>–û—Ä—É–∂–∏–µ: –ö–ª—É–±–æ–∫</div></div>
            <div class="card" onclick="game.start('black')"><span class="card-icon">üêà‚Äç‚¨õ</span><div class="card-title">–ß–µ—Ä–Ω—ã–π</div><div class="card-desc">–£–¥–∞—á–∞ –∏ –ö—Ä–∏—Ç.<br>–û—Ä—É–∂–∏–µ: –ö–æ–≥—Ç–∏</div></div>
            <div class="card" onclick="game.start('siamese')"><span class="card-icon">‚ú®</span><div class="card-title">–°–∏–∞–º—Å–∫–∏–π</div><div class="card-desc">–ú–∞–≥. –û–±–ª–∞—Å—Ç—å +20%.<br>–û—Ä—É–∂–∏–µ: –ê—É—Ä–∞</div></div>
            <div class="card" onclick="game.start('ragdoll')"><span class="card-icon">üß∂</span><div class="card-title">–†—ç–≥–¥–æ–ª–ª</div><div class="card-desc">–ë—Ä–æ–Ω—è. –í–æ–∑–≤—Ä–∞—Ç —É—Ä–æ–Ω–∞.<br>–û—Ä—É–∂–∏–µ: –ë–æ–º–±–∞</div></div>
            <div class="card" onclick="game.start('persian')"><span class="card-icon">üëë</span><div class="card-title">–ü–µ—Ä—Å</div><div class="card-desc">–õ–µ–Ω–∏–≤—ã–π. –†–µ–≥–µ–Ω HP.<br>–û—Ä—É–∂–∏–µ: –†—ã–±–∞</div></div>
        </div>
    </div>

    <div id="upgrade-screen" class="screen" style="display: none;">
        <h1 id="upg-title">LEVEL UP!</h1>
        <div class="cards-container" id="upgrade-cards"></div>
    </div>

    <div id="shop-screen" class="screen" style="display: none;">
        <h1 style="color:#f1c40f">–õ–∞–≤–∫–∞ –ï–Ω–æ—Ç–∞</h1>
        <h2 id="shop-coins">–í–∞—à–∏ –º–æ–Ω–µ—Ç—ã: 0</h2>
        <div class="cards-container" id="shop-cards"></div>
        <button class="btn" onclick="game.closeShop(false)">–£–π—Ç–∏</button>
    </div>

    <div id="game-over-screen" class="screen" style="display: none;">
        <h1 id="go-title">–ö–û–ù–ï–¶ –ò–ì–†–´</h1>
        <h2 id="go-stats">...</h2>
        <button class="btn" onclick="game.resetGame()">–ú–µ–Ω—é</button>
    </div>

<script>
// --- TELEGRAM INIT ---
if(window.Telegram && window.Telegram.WebApp) {
    window.Telegram.WebApp.ready();
    window.Telegram.WebApp.expand();
}

// --- INTRO LOGIC ---
const introSeenKey = 'cat_rpg_intro_seen_v3'; // –ò–∑–º–µ–Ω–∏–ª –∫–ª—é—á, —á—Ç–æ–±—ã –∏–Ω—Ç—Ä–æ –ø–æ–∫–∞–∑–∞–ª–æ—Å—å —Å–Ω–æ–≤–∞
const hasSeenIntro = localStorage.getItem(introSeenKey);
if(!hasSeenIntro) {
    document.getElementById('intro-screen').style.display = 'flex';
} else {
    document.getElementById('class-screen').style.display = 'flex';
}

let currentSlide = 0;
const slides = document.querySelectorAll('.slide');
function nextSlide() {
    slides[currentSlide].classList.remove('active');
    currentSlide++;
    if(currentSlide >= slides.length) startGameFlow();
    else slides[currentSlide].classList.add('active');
}
function startGameFlow() {
    localStorage.setItem(introSeenKey, 'true');
    document.getElementById('intro-screen').style.display = 'none';
    document.getElementById('class-screen').style.display = 'flex';
}

// --- CONFIG ---
const CONFIG = {
    worldSize: 50000, 
    colors: { grass: '#2d9e6d', grassDark: '#268b5e' },
    mobileZoomMod: 1.5 // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –æ—Ç–¥–∞–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.Telegram && window.Telegram.WebApp.initData);

// --- –£–õ–£–ß–®–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø RESIZE (–î–õ–Ø –ó–£–ú–ê) ---
function resize() {
    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –æ–∫–Ω–∞
    let displayWidth = window.innerWidth;
    let displayHeight = window.innerHeight;

    // –ï—Å–ª–∏ —ç—Ç–æ –º–æ–±–∏–ª—å–Ω—ã–π, –º—ã –æ–±–º–∞–Ω—ã–≤–∞–µ–º –∫–∞–Ω–≤–∞—Å, –≥–æ–≤–æ—Ä—è –µ–º—É, —á—Ç–æ –æ–Ω –±–æ–ª—å—à–µ,
    // —á–µ–º —ç–∫—Ä–∞–Ω –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ. –≠—Ç–æ —Å–æ–∑–¥–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç "–æ—Ç–¥–∞–ª–µ–Ω–∏—è" –∫–∞–º–µ—Ä—ã.
    if (isMobile) {
        canvas.width = displayWidth * CONFIG.mobileZoomMod;
        canvas.height = displayHeight * CONFIG.mobileZoomMod;
        document.getElementById('joystick-area').style.display = 'block';
    } else {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
    }

    // –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞ –≤—Å–µ–≥–¥–∞ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
    miniCanvas.width = 200; miniCanvas.height = 200;
}
window.addEventListener('resize', resize);
// –í—ã–∑—ã–≤–∞–µ–º resize –Ω–µ —Å—Ä–∞–∑—É, –∞ —á–µ—Ä–µ–∑ –Ω–µ–±–æ–ª—å—à–æ–π —Ç–∞–π–º–∞—É—Ç, —á—Ç–æ–±—ã –±—Ä–∞—É–∑–µ—Ä —É—Å–ø–µ–ª —É–±—Ä–∞—Ç—å –∞–¥—Ä–µ—Å–Ω—É—é —Å—Ç—Ä–æ–∫—É –Ω–∞ –º–æ–±–∏–ª–∫–∞—Ö
setTimeout(resize, 100);


// --- INPUT & JOYSTICK ---
const input = { keys: {}, joystick: { x: 0, y: 0, active: false } };
window.addEventListener('keydown', e => input.keys[e.code] = true);
window.addEventListener('keyup', e => input.keys[e.code] = false);

const joyBase = document.querySelector('.joy-base');
const joyStick = document.getElementById('joy-stick');
let joyTouchId = null;

joyBase.addEventListener('touchstart', e => { e.preventDefault(); joyTouchId = e.changedTouches[0].identifier; input.joystick.active = true; }, {passive:false});
joyBase.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = Array.from(e.changedTouches).find(t => t.identifier === joyTouchId);
    if(!touch) return;
    const rect = joyBase.getBoundingClientRect();
    const maxDist = rect.width/2 - 25;
    // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞—Å–∞–Ω–∏—è —Å —É—á–µ—Ç–æ–º –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è UI
    const uiScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ui-scale')) || 1;
    let dx = (touch.clientX - (rect.left + rect.width/2)) / uiScale;
    let dy = (touch.clientY - (rect.top + rect.height/2)) / uiScale;

    const dist = Math.hypot(dx, dy);
    if(dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
    joyStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    input.joystick.x = dx / maxDist; input.joystick.y = dy / maxDist;
}, {passive:false});
const endJoy = (e) => { e.preventDefault(); joyTouchId = null; input.joystick.active = false; input.joystick.x=0; input.joystick.y=0; joyStick.style.transform = `translate(-50%, -50%)`; };
joyBase.addEventListener('touchend', endJoy); joyBase.addEventListener('touchcancel', endJoy);

// --- UTILS ---
function drawCircle(ctx, x, y, r, color, stroke=null) {
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle=color; ctx.fill();
    if(stroke) { ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.stroke(); }
}

// --- GAME CLASSES ---

class Camera {
    constructor() { this.x = 0; this.y = 0; }
    follow(t) {
        // –ü–ª–∞–≤–Ω–æ —Å–ª–µ–¥—É–µ–º –∑–∞ –∏–≥—Ä–æ–∫–æ–º, —Ü–µ–Ω—Ç—Ä–∏—Ä—É—è –µ–≥–æ –Ω–∞ –∫–∞–Ω–≤–∞—Å–µ
        this.x += (t.x - canvas.width/2 - this.x) * 0.1;
        this.y += (t.y - canvas.height/2 - this.y) * 0.1;
        this.x = Math.max(0, Math.min(this.x, CONFIG.worldSize - canvas.width));
        this.y = Math.max(0, Math.min(this.y, CONFIG.worldSize - canvas.height));
    }
}

class Entity {
    constructor(x, y, r) { this.x = x; this.y = y; this.r = r; this.dead = false; }
    isVisible(cx, cy) { return this.x+this.r+50 > cx && this.x-this.r-50 < cx+canvas.width && this.y+this.r+50 > cy && this.y-this.r-50 < cy+canvas.height; }
    resolveObstacle(o) {
        const dx = this.x - o.x; const dy = this.y - o.y; const dist = Math.hypot(dx, dy); const minDist = this.r + o.r;
        if (dist < minDist) {
            const angle = Math.atan2(dy, dx);
            const push = minDist - dist;
            this.x += Math.cos(angle) * push; this.y += Math.sin(angle) * push;
        }
    }
}

class Obstacle extends Entity {
    constructor(x, y, type) { super(x, y, type==='tree'?35:30); this.type = type; }
    draw(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; drawCircle(ctx, this.x+5, this.y+5, this.r, null); 
        if(this.type === 'tree') {
            drawCircle(ctx, this.x, this.y, 15, '#5d4037');
            drawCircle(ctx, this.x, this.y-25, 45, '#1e8449', '#145a32');
            drawCircle(ctx, this.x-15, this.y-40, 15, '#2ecc71');
        } else {
            ctx.fillStyle = '#7f8c8d'; ctx.strokeStyle = '#535c68'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.roundRect(this.x-30, this.y-25, 60, 50, 10); ctx.fill(); ctx.stroke();
            drawCircle(ctx, this.x-10, this.y-10, 5, '#95a5a6');
        }
    }
}

class SuperAltar extends Entity {
    constructor() {
        super(Math.random()*(CONFIG.worldSize-1000)+500, Math.random()*(CONFIG.worldSize-1000)+500, 200);
        this.active = true;
    }
    update() {
        if(!this.active) return;
        const d = Math.hypot(game.player.x - this.x, game.player.y - this.y);
        
        // Hide warning if far away
        if (d > this.r + 200) {
             document.getElementById('altar-warning').style.display = 'none';
        } else if (d < this.r + 50 && game.time < 600) {
             const w = document.getElementById('altar-warning');
             w.style.display = 'block';
             w.innerText = `–ü–ï–ß–ê–¢–¨: ${Math.ceil(600 - game.time)} —Å–µ–∫`;
        } 

        if (d < this.r && game.time >= 600) {
            this.active = false;
            game.spawnSuperBoss(this.x, this.y);
            document.getElementById('altar-warning').style.display = 'none';
        }
    }
    draw(ctx) {
        if(!this.active) return;
        ctx.fillStyle = 'rgba(75, 0, 130, 0.3)';
        ctx.beginPath(); ctx.arc(this.x, this.y, 400, 0, Math.PI*2); ctx.fill();
        
        ctx.strokeStyle = game.time >= 600 ? '#f0f' : '#555';
        ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
        
        ctx.font = '30px serif'; ctx.fillStyle='#fff'; ctx.fillText('‚ò†Ô∏è', this.x-15, this.y+10);
    }
}

class Merchant extends Entity {
    constructor() { super(Math.random()*(CONFIG.worldSize-500)+250, Math.random()*(CONFIG.worldSize-500)+250, 40); }
    update() {
        if(Math.hypot(game.player.x - this.x, game.player.y - this.y) < this.r + 30) {
            game.openShop(this);
        }
    }
    draw(ctx) {
        drawCircle(ctx, this.x, this.y, 30, '#95a5a6', '#2c3e50'); 
        drawCircle(ctx, this.x, this.y-5, 20, '#fff'); 
        drawCircle(ctx, this.x-8, this.y-5, 3, '#000'); 
        drawCircle(ctx, this.x+8, this.y-5, 3, '#000'); 
        ctx.fillStyle='#f1c40f'; ctx.font='20px sans-serif'; ctx.fillText('üõí', this.x-12, this.y-35);
    }
}

class Enemy extends Entity {
    constructor(isBoss=false, isSuperBoss=false, x, y) {
        if(!x) {
            const angle = Math.random()*Math.PI*2;
            const dist = 900;
            x = Math.max(100, Math.min(CONFIG.worldSize-100, game.player.x + Math.cos(angle)*dist));
            y = Math.max(100, Math.min(CONFIG.worldSize-100, game.player.y + Math.sin(angle)*dist));
        }
        
        super(x, y, isBoss?60:20);
        this.isBoss = isBoss;
        this.isSuperBoss = isSuperBoss;
        
        if(isSuperBoss) {
            this.r = 100;
            this.type = 'lich'; this.maxHp = 50000; this.hp = this.maxHp;
            this.xp = 10000; this.dmg = 200; this.speed = 3.0; this.armor = 50;
        } else {
            const mins = game.time / 60;
            const hpMult = 1 + (mins * 0.4);
            const dmgMult = 1 + (mins * 0.2);
            this.armor = Math.floor(mins * 2);
            
            if(isBoss) {
                this.type = 'demon'; this.maxHp = 5000 * hpMult; this.hp = this.maxHp; 
                this.xp = 1000; this.dmg = 40 * dmgMult; this.speed = 2.4; this.armor += 10;
            } else {
                const r = Math.random();
                if(r < 0.3) { this.type='slime'; this.maxHp=30*hpMult; this.speed=1.6; this.dmg=8*dmgMult; this.xp=5; }
                else if(r < 0.6) { this.type='bat'; this.maxHp=20*hpMult; this.speed=2.7; this.dmg=5*dmgMult; this.xp=5; }
                else if(r < 0.8) { this.type='ghost'; this.maxHp=50*hpMult; this.speed=1.3; this.dmg=15*dmgMult; this.xp=10; this.armor+=5;}
                else { this.type='spider'; this.maxHp=80*hpMult; this.speed=1.2; this.dmg=12*dmgMult; this.xp=15; this.armor+=2;}
                this.hp = this.maxHp;
            }
        }
    }

    update() {
        const ang = Math.atan2(game.player.y-this.y, game.player.x-this.x);
        this.x += Math.cos(ang)*this.speed;
        this.y += Math.sin(ang)*this.speed;

        if(this.isBoss || this.isSuperBoss) {
            game.obstacles.forEach((o, index) => {
                if(o && Math.hypot(this.x-o.x, this.y-o.y) < this.r + o.r) {
                    game.particles.push(new Particle(o.x, o.y, '#7f8c8d'));
                    delete game.obstacles[index]; 
                }
            });
        } else {
            game.obstacles.forEach(o => {
                if(o && this.isVisible(game.camera.x, game.camera.y)) this.resolveObstacle(o);
            });
        }
    }

    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        
        if(this.isBoss || this.isSuperBoss) {
            ctx.fillStyle='red'; ctx.fillRect(-50, -this.r-20, 100, 10);
            ctx.fillStyle='#0f0'; ctx.fillRect(-50, -this.r-20, 100 * (Math.max(0,this.hp)/this.maxHp), 10);
        }

        if(this.isSuperBoss) {
             drawCircle(ctx, 0, 0, 80, '#2c0e3a', '#e056fd');
             ctx.fillStyle='#fff'; 
             ctx.beginPath(); ctx.arc(-20, -10, 10, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(20, -10, 10, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(-20, -10, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20, -10, 3, 0, Math.PI*2); ctx.fill();
        } else if(this.type === 'slime') {
            ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(0,0,20,Math.PI, 0); ctx.fill();
            ctx.fillRect(-20,0,40,10); 
            ctx.fillStyle = '#000'; drawCircle(ctx, -5, -5, 3, '#000'); drawCircle(ctx, 5, -5, 3, '#000');
        } else if (this.type === 'bat') {
            ctx.fillStyle = '#8e44ad'; 
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-20,-15); ctx.lineTo(-10,5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20,-15); ctx.lineTo(10,5); ctx.fill();
            drawCircle(ctx, 0, 0, 10, '#34495e');
        } else if (this.type === 'ghost') {
            ctx.fillStyle = 'rgba(236, 240, 241, 0.8)';
            ctx.beginPath(); ctx.arc(0,-10,15,Math.PI,0); ctx.lineTo(15,20); ctx.lineTo(0,10); ctx.lineTo(-15,20); ctx.fill();
            ctx.fillStyle = '#000'; drawCircle(ctx, -6, -10, 2, '#000'); drawCircle(ctx, 6, -10, 2, '#000');
        } else if (this.type === 'spider') {
            ctx.strokeStyle = '#2c3e50'; ctx.lineWidth=2;
            for(let i=0; i<4; i++) { ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(i)*25, Math.sin(i)*25); ctx.stroke(); }
            drawCircle(ctx, 0, 0, 12, '#2c3e50'); ctx.fillStyle='red'; drawCircle(ctx, 0, -5, 2, 'red');
        } else if (this.type === 'demon') {
            drawCircle(ctx, 0, 0, 50, '#c0392b', '#000');
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath(); ctx.moveTo(-20,-30); ctx.lineTo(-40,-60); ctx.lineTo(-10,-40); ctx.fill();
            ctx.beginPath(); ctx.moveTo(20,-30); ctx.lineTo(40,-60); ctx.lineTo(10,-40); ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.moveTo(-30,-10); ctx.lineTo(-10,-10); ctx.lineTo(-20, 10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(30,-10); ctx.lineTo(10,-10); ctx.lineTo(20, 10); ctx.fill();
        }
        ctx.restore();
    }
}

class Player extends Entity {
    constructor(type) {
        super(CONFIG.worldSize/2, CONFIG.worldSize/2, 20);
        this.type = type;
        this.hp = 100; this.maxHp = 100;
        this.xp = 0; this.xpNext = 20; this.lvl = 1; this.speed = 4;
        this.weapons = []; this.facing = 1; 
        
        this.globalCount = 0;
        this.armorPen = 0; 
        this.areaMod = 1.0;
        this.armor = 0;
        this.regen = 0;
        this.magnetRange = 150;

        if(type==='mainecoon') { this.maxHp=200; this.hp=200; this.speed=2.9; this.addWeapon('paw'); }
        if(type==='sphynx') { this.maxHp=80; this.hp=80; this.speed=5.1; this.addWeapon('laser'); }
        if(type==='tabby') { this.speed=3.4; this.addWeapon('yarn'); }
        if(type==='black') { this.critChance = 0.2; this.speed=3.4; this.addWeapon('shadow_claws'); }
        if(type==='siamese') { this.areaMod = 1.2; this.speed=3.4; this.addWeapon('garlic'); }
        if(type==='ragdoll') { this.armor = 5; this.maxHp=150; this.hp=150; this.speed=2.5; this.addWeapon('bomb_weapon'); }
        if(type==='persian') { this.regen = 1; this.speed=2.1; this.addWeapon('fish'); }
    }

    addWeapon(id, isMega=false) {
        const existing = this.weapons.find(w => w.id === id);
        if(!existing && this.weapons.length >= 4) return false;
        if(existing) { if(isMega) existing.megaUpgrade(); else existing.upgrade(); }
        else { const w = new Weapon(id, this); if(isMega) w.megaUpgrade(); this.weapons.push(w); this.updateWeaponUI(); }
        return true;
    }
    
    updateWeaponUI() {
        const list = document.getElementById('weapons-list');
        list.innerHTML = '';
        this.weapons.forEach(w => {
            const el = document.createElement('div');
            el.innerHTML = w.icon || '‚ùì';
            el.style.cssText = 'width:25px;height:25px;background:#333;border-radius:50%;text-align:center;font-size:16px;line-height:25px;border:1px solid #fff;';
            list.appendChild(el);
        });
    }

    update() {
        if(this.regen > 0 && Math.random() < 0.01) this.hp = Math.min(this.maxHp, this.hp + this.regen);
        let dx=0, dy=0;
        if(input.joystick.active) { dx=input.joystick.x; dy=input.joystick.y; }
        else {
            if(input.keys['KeyW'] || input.keys['ArrowUp']) dy=-1;
            if(input.keys['KeyS'] || input.keys['ArrowDown']) dy=1;
            if(input.keys['KeyA'] || input.keys['ArrowLeft']) dx=-1;
            if(input.keys['KeyD'] || input.keys['ArrowRight']) dx=1;
        }
        if(!input.joystick.active && (dx||dy)) { const l=Math.hypot(dx,dy); dx/=l; dy/=l; }
        this.x += dx*this.speed; this.y += dy*this.speed;
        game.obstacles.forEach(o => { if(o) this.resolveObstacle(o); });
        this.x = Math.max(50, Math.min(CONFIG.worldSize-50, this.x));
        this.y = Math.max(50, Math.min(CONFIG.worldSize-50, this.y));
        if(dx>0) this.facing=1; if(dx<0) this.facing=-1;
        this.weapons.forEach(w => w.update());
    }
    
    draw(ctx) {
        this.weapons.forEach(w => w.draw(ctx));
        ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
        let color = '#fff';
        if(this.type==='mainecoon') color='#5d4037';
        if(this.type==='black') color='#2d3436';
        if(this.type==='siamese') color='#f5f6fa';
        if(this.type==='persian') color='#ecf0f1';
        drawCircle(ctx, 0, 5, 20, color, '#000'); 
        drawCircle(ctx, 0, -10, 16, color, '#000'); 
        ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(-10,-20); ctx.lineTo(-15,-35); ctx.lineTo(-5,-25); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10,-20); ctx.lineTo(15,-35); ctx.lineTo(5,-25); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#fff'; drawCircle(ctx, 5, -10, 4, '#fff'); drawCircle(ctx, -5, -10, 4, '#fff');
        ctx.fillStyle='#000'; drawCircle(ctx, 5, -10, 2, '#000'); drawCircle(ctx, -5, -10, 2, '#000');
        ctx.restore();
    }
}

class Weapon {
    constructor(id, owner) {
        this.id = id; this.owner = owner; this.level = 1; this.cd = 0;
        this.stats = { dmg: 10, speed: 1, size: 1, maxCd: 60, count: 1, area: 100, duration: 60 };
        this.setup();
    }
    setup() {
        if(this.id==='paw') { this.name="–õ–∞–ø–∞"; this.icon="üêæ"; this.stats={dmg:25, maxCd:40, speed:8, count:1, range:300}; }
        if(this.id==='yarn') { this.name="–ö–ª—É–±–æ–∫"; this.icon="üß∂"; this.stats={dmg:12, maxCd:0, speed:0.04, count:1, dist:80, size:10}; }
        if(this.id==='laser') { this.name="–õ–∞–∑–µ—Ä"; this.icon="üî¥"; this.stats={dmg:5, maxCd:5, range:400}; }
        if(this.id==='fish') { this.name="–ö–æ—Å—Ç—å"; this.icon="üêü"; this.stats={dmg:40, maxCd:70, speed:6, count:1}; }
        if(this.id==='shadow_claws') { this.name="–¢–µ–Ω—å"; this.icon="üåë"; this.stats={dmg:60, maxCd:50, range:100, area: 80}; }
        if(this.id==='bomb_weapon') { this.name="–ú—è—Ç–∞"; this.icon="üí£"; this.stats={dmg:100, maxCd:150, area:150}; }
        if(this.id==='water') { this.name="–ë—Ä—ã–∑–≥–∏"; this.icon="üí¶"; this.stats={dmg:10, maxCd:60, count:3, speed:4}; }
        if(this.id==='garlic') { this.name="–ê—É—Ä–∞"; this.icon="‚ú®"; this.stats={dmg:3, maxCd:15, area:90}; }
    }
    upgrade(stat1, stat2) {
        this.level++;
        const applyStat = (type) => {
            if(type === 'dmg') this.stats.dmg = Math.ceil(this.stats.dmg * 1.2);
            if(type === 'cd') this.stats.maxCd *= 0.85;
            if(type === 'count') this.stats.count += 1;
            if(type === 'area') this.stats.area *= 1.2;
            if(type === 'speed') this.stats.speed *= 1.1;
        };
        if(!stat1) { this.stats.dmg *= 1.2; return; }
        applyStat(stat1); if(stat2) applyStat(stat2);
    }
    megaUpgrade() { this.level+=3; this.stats.dmg*=2; this.stats.count+=2; }
    
    update() {
        if(this.cd > 0) this.cd--;
        const totalCount = this.stats.count + this.owner.globalCount;
        const areaMult = this.owner.areaMod;
        const owner = this.owner;

        if(this.id === 'paw' && this.cd <= 0) {
            const t = game.getNearestEnemy(owner, this.stats.range);
            if(t) {
                for(let i=0; i<totalCount; i++) game.projectiles.push(new Projectile(owner.x, owner.y, t, 'paw', this.stats, (i-(totalCount-1)/2)*0.2));
                this.cd = this.stats.maxCd;
            }
        }
        if(this.id === 'laser' && this.cd <= 0) {
            const t = game.getNearestEnemy(owner, 400);
            if(t) {
                game.projectiles.push(new Projectile(owner.x, owner.y, t, 'laser', this.stats, 0));
                this.cd = this.stats.maxCd;
            }
        }
        if(this.id === 'fish' && this.cd <= 0) {
             const t = game.getNearestEnemy(owner, 500);
             if(t) { game.projectiles.push(new Projectile(owner.x, owner.y, t, 'fish', this.stats, 0)); this.cd = this.stats.maxCd; }
        }
        if(this.id === 'bomb_weapon' && this.cd <= 0) {
            game.projectiles.push(new Projectile(owner.x, owner.y, null, 'bomb', { ...this.stats, area: this.stats.area*areaMult }));
            this.cd = this.stats.maxCd;
        }
        if(this.id === 'shadow_claws' && this.cd <= 0) {
            const angle = owner.facing === 1 ? 0 : Math.PI;
            game.createExplosion(owner.x + Math.cos(angle)*50, owner.y, this.stats.area*areaMult, this.stats.dmg, '#2d3436');
            this.cd = this.stats.maxCd;
        }
        if(this.id === 'garlic' && this.cd <= 0) {
            game.enemies.forEach(e => { if(Math.hypot(e.x-owner.x, e.y-owner.y) < this.stats.area * areaMult) game.damageEnemy(e, this.stats.dmg); });
            this.cd = this.stats.maxCd;
        }
    }
    
    draw(ctx) {
        const totalCount = this.stats.count + this.owner.globalCount;
        if(this.id === 'yarn') {
            const step = (Math.PI*2)/totalCount;
            const now = Date.now()*0.001*this.stats.speed*10;
            for(let i=0; i<totalCount; i++) {
                const ang = now + i*step;
                const bx = this.owner.x + Math.cos(ang)*this.stats.dist;
                const by = this.owner.y + Math.sin(ang)*this.stats.dist;
                drawCircle(ctx, bx, by, this.stats.size, '#e74c3c');
                ctx.strokeStyle='rgba(231,76,60,0.5)'; ctx.beginPath(); ctx.moveTo(this.owner.x, this.owner.y); ctx.lineTo(bx, by); ctx.stroke();
                game.enemies.forEach(e => { if(Math.hypot(bx-e.x, by-e.y) < this.stats.size+e.r) game.damageEnemy(e, this.stats.dmg); });
            }
        }
        if(this.id === 'garlic') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.beginPath(); ctx.arc(this.owner.x, this.owner.y, this.stats.area * this.owner.areaMod, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth=1; ctx.stroke();
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, target, type, stats, angOff=0) {
        super(x, y, 10);
        this.type = type; this.dmg = stats.dmg; this.speed = stats.speed; this.target = target;
        this.timer = 120;
        if(type==='bomb') { this.timer = 60; this.area = stats.area; } 
        else {
            const ang = Math.atan2(target.y - y, target.x - x) + angOff;
            this.vx = Math.cos(ang)*this.speed; this.vy = Math.sin(ang)*this.speed;
            this.angle = ang;
            if(type==='fish') { this.returnState = 0; this.timer=200; }
        }
    }
    update() {
        if(this.type === 'bomb') {
            this.timer--;
            if(this.timer <= 0) { this.dead = true; game.createExplosion(this.x, this.y, this.area, this.dmg, '#2ecc71'); }
            return;
        }
        if(this.type === 'fish') {
            this.timer--;
            if(this.timer < 160 && this.returnState === 0) { this.returnState = 1; }
            if(this.returnState === 1) {
                const ang = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                this.vx += Math.cos(ang) * 0.5; this.vy += Math.sin(ang) * 0.5;
                const l = Math.hypot(this.vx, this.vy);
                if(l > this.speed) { this.vx = (this.vx/l)*this.speed; this.vy = (this.vy/l)*this.speed; }
                if(Math.hypot(game.player.x - this.x, game.player.y - this.y) < 20) this.dead = true;
            }
        }
        this.x += this.vx; this.y += this.vy;
        if(this.type !== 'fish') { this.timer--; if(this.timer <= 0) this.dead = true; }
    }
    draw(ctx) {
        if(this.type === 'bomb') {
            drawCircle(ctx, this.x, this.y, 10, '#e74c3c');
            if(Math.floor(Date.now()/100)%2===0) ctx.fillStyle='#fff'; else ctx.fillStyle='red';
            ctx.beginPath(); ctx.arc(this.x, this.y-5, 3, 0, Math.PI*2); ctx.fill();
            return;
        }
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        if(this.type==='paw') drawCircle(ctx, 0, 0, 8, '#00f0ff');
        else if (this.type==='laser') { ctx.fillStyle='red'; ctx.fillRect(-10, -2, 20, 4); }
        else if (this.type==='fish') { ctx.fillStyle='#fff'; ctx.font='20px serif'; ctx.fillText('üêü', -10, 5); }
        ctx.restore();
    }
}

class FloatingText extends Entity {
    constructor(x, y, text, color) { super(x, y, 0); this.text = text; this.color = color; this.life = 1.0; }
    update() { this.y -= 1; this.life -= 0.02; if(this.life<=0) this.dead=true; }
    draw(ctx) { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.font = "bold 20px 'Fredoka One'"; ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha=1; }
}

class Coin extends Entity {
    constructor(x, y) { super(x, y, 8); }
    update() {
        const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
        if(dist < game.player.magnetRange) {
             const ang = Math.atan2(game.player.y - this.y, game.player.x - this.x);
             this.x += Math.cos(ang) * 12; this.y += Math.sin(ang) * 12;
             if(dist < 30) { this.dead = true; game.addCoins(1); }
        }
    }
    draw(ctx) { drawCircle(ctx, this.x, this.y, 6, '#f1c40f', '#f39c12'); ctx.fillStyle='#fff'; ctx.font="10px sans-serif"; ctx.fillText("$", this.x-3, this.y+3); }
}

class Particle extends Entity {
    constructor(x, y, col) { super(x, y, 0); this.col = col; this.life = 1.0; this.vx=(Math.random()-0.5)*5; this.vy=(Math.random()-0.5)*5; }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; if(this.life<=0) this.dead=true; }
    draw(ctx) { ctx.globalAlpha=this.life; drawCircle(ctx, this.x, this.y, 4, this.col); ctx.globalAlpha=1; }
}

class Pickup extends Entity {
    constructor(x, y, type) { super(x, y, 15); this.type = type; this.bob = 0; }
    update() { this.bob += 0.1; }
    draw(ctx) {
        const yOff = Math.sin(this.bob) * 5;
        ctx.save(); ctx.translate(this.x, this.y + yOff);
        ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; ctx.font = '24px serif';
        let t = 'üì¶';
        if(this.type === 'potion') t = '‚ù§Ô∏è';
        else if(this.type === 'magnet') t = 'üß≤';
        else if(this.type === 'chest') t = 'üëë';
        ctx.fillText(t, -12, 8);
        ctx.restore();
    }
}

// --- GAME ENGINE ---

class Game {
    constructor() {
        this.camera = new Camera();
        this.projectiles=[]; this.particles=[]; this.enemies=[]; this.obstacles=[];
        this.xpOrbs=[]; this.pickups=[]; this.texts=[]; this.coinsList=[]; this.merchants=[];
        this.time=0; this.kills=0; this.coins=0; this.bossTimer=0;
    }

    initWorld() {
        for(let i=0; i<10000; i++) {
            const x = Math.random() * CONFIG.worldSize;
            const y = Math.random() * CONFIG.worldSize;
            if(Math.hypot(x-CONFIG.worldSize/2, y-CONFIG.worldSize/2) > 500) {
                this.obstacles.push(new Obstacle(x, y, Math.random()>0.3?'tree':'stone'));
            }
        }
        for(let i=0; i<20; i++) this.merchants.push(new Merchant());
        this.superAltar = new SuperAltar();
    }

    start(type) {
        document.getElementById('class-screen').style.display='none';
        document.getElementById('ui-layer').style.display='block';
        this.initWorld();
        this.player = new Player(type);
        this.camera.x = this.player.x-canvas.width/2; this.camera.y = this.player.y-canvas.height/2;
        this.enemies=[]; this.projectiles=[]; this.xpOrbs=[]; this.pickups=[]; this.texts=[]; this.coinsList=[];
        this.time=0; this.startTime = Date.now(); this.lastBossTime = 0; this.kills=0; this.coins=0; this.state='PLAYING';
        this.updateHUD(); this.loop();
    }
    
    resetGame() {
        this.state = 'MENU';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'none';
        document.getElementById('class-screen').style.display = 'flex';
        this.enemies = []; this.obstacles = []; this.projectiles = [];
    }

    loop() {
        if(this.state !== 'PLAYING') return;
        requestAnimationFrame(()=>this.loop());

        const now = Date.now();
        this.time = (now - this.startTime) / 1000;
        
        const mins = Math.floor(this.time/60).toString().padStart(2,'0');
        const secs = Math.floor(this.time%60).toString().padStart(2,'0');
        document.getElementById('game-timer').innerText = `${mins}:${secs}`;

        this.player.update();
        this.camera.follow(this.player);

        // Spawn
        const maxEnemies = 40 + Math.floor(this.time/20);
        if(this.enemies.length < maxEnemies && Math.random() < 0.03) {
            this.enemies.push(new Enemy(false));
        }

        if(this.time > 10 && Math.floor(this.time) % 60 === 0 && Math.floor(this.time) !== this.lastBossTime) {
            this.lastBossTime = Math.floor(this.time);
            this.spawnBoss();
        }

        this.superAltar.update();
        [this.projectiles, this.enemies, this.particles, this.xpOrbs, this.coinsList, this.pickups, this.merchants, this.texts].forEach(arr => arr.forEach(e => e.update()));

        this.checkCollisions();
        
        this.projectiles=this.projectiles.filter(x=>!x.dead);
        this.enemies=this.enemies.filter(x=>!x.dead);
        this.particles=this.particles.filter(x=>!x.dead);
        this.xpOrbs=this.xpOrbs.filter(x=>!x.dead);
        this.coinsList=this.coinsList.filter(x=>!x.dead);
        this.pickups=this.pickups.filter(x=>!x.dead);
        this.merchants=this.merchants.filter(x=>!x.dead);
        this.texts=this.texts.filter(x=>!x.dead);

        this.draw();
        this.drawMinimap();
    }
    
    spawnBoss() {
        this.enemies.push(new Enemy(true));
        this.texts.push(new FloatingText(this.player.x, this.player.y-80, "‚ò†Ô∏è –ë–û–°–° –ü–†–ò–®–ï–õ! ‚ò†Ô∏è", "red"));
    }
    
    spawnSuperBoss(x, y) {
        const boss = new Enemy(false, true, x, y);
        this.enemies.push(boss);
        this.texts.push(new FloatingText(x, y-100, "‚ò†Ô∏è –õ–ò–ß –ü–†–û–ë–£–î–ò–õ–°–Ø ‚ò†Ô∏è", "#e056fd"));
    }

    createExplosion(x, y, r, dmg, color) {
        for(let i=0; i<10; i++) this.particles.push(new Particle(x + (Math.random()-0.5)*r, y + (Math.random()-0.5)*r, color));
        this.enemies.forEach(e => {
            if(Math.hypot(e.x-x, e.y-y) < r + e.r) this.damageEnemy(e, dmg);
        });
    }

    checkCollisions() {
        this.enemies.forEach(e => {
            if(Math.hypot(this.player.x-e.x, this.player.y-e.y) < this.player.r+e.r) {
                const dmg = Math.max(1, 10 - this.player.armor);
                this.player.hp -= dmg * 0.05;
                this.updateHUD();
                if(this.player.hp<=0) this.gameOver();
            }
        });
        this.projectiles.forEach(p => {
            this.enemies.forEach(e => {
                if(Math.hypot(p.x-e.x, p.y-e.y) < p.r+e.r) {
                    this.damageEnemy(e, p.dmg);
                    if(p.type!=='garlic' && p.type!=='bomb') p.dead=true;
                }
            });
        });
        this.pickups.forEach(p => {
             if(Math.hypot(this.player.x-p.x, this.player.y-p.y) < this.player.r+p.r) {
                 this.collectPickup(p); p.dead = true;
             }
        });
    }

    damageEnemy(e, rawDmg) {
        const armor = Math.max(0, e.armor - this.player.armorPen);
        const actualDmg = Math.max(1, rawDmg - armor);
        e.hp -= actualDmg;
        this.texts.push(new FloatingText(e.x, e.y-e.r, Math.floor(actualDmg), '#fff'));
        
        if(e.hp<=0 && !e.dead) {
            e.dead = true; this.kills++;
            this.coinsList.push(new Coin(e.x, e.y));
            if(e.isSuperBoss) {
                this.pickups.push(new Pickup(e.x, e.y, 'chest')); // Mega Chest
                this.player.weapons.forEach(w => { w.stats.dmg *= 5; w.stats.size *= 1.5; }); // Divine Power
                this.texts.push(new FloatingText(e.x, e.y, "–ë–û–ñ–ï–°–¢–í–ï–ù–ù–ê–Ø –°–ò–õ–ê!", "gold"));
            } else if(e.isBoss) {
                this.pickups.push(new Pickup(e.x, e.y, 'chest'));
            } else {
                this.xpOrbs.push({x: e.x, y: e.y, val: e.xp, dead:false, update: function(){
                    if(Math.hypot(game.player.x-this.x, game.player.y-this.y) < game.player.magnetRange) {
                        this.x += (game.player.x-this.x)*0.15; this.y += (game.player.y-this.y)*0.15;
                        if(Math.hypot(game.player.x-this.x, game.player.y-this.y) < 20) { this.dead=true; game.addXP(this.val); }
                    }
                }, draw: function(ctx){ ctx.fillStyle='#2ed573'; ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill(); }});
                
                if(Math.random() < 0.02) this.pickups.push(new Pickup(e.x, e.y, Math.random()>0.5?'potion':'magnet'));
            }
            this.particles.push(new Particle(e.x, e.y, '#fff'));
            this.updateHUD();
        }
    }

    addXP(v) {
        this.player.xp+=v;
        if(this.player.xp >= this.player.xpNext) {
            this.player.xp -= this.player.xpNext; this.player.lvl++; this.player.xpNext=Math.floor(this.player.xpNext*1.5);
            this.triggerLevelUp();
        }
        this.updateHUD();
    }
    
    addCoins(v) { this.coins += v; this.updateHUD(); }
    getNearestEnemy(s, r) { let n=null, md=r; this.enemies.forEach(e=>{const d=Math.hypot(s.x-e.x, s.y-e.y); if(d<md){md=d; n=e;}}); return n; }

    // --- UI ---

    updateHUD() {
        document.getElementById('hp-bar').style.width = Math.max(0, (this.player.hp/this.player.maxHp)*100)+'%';
        document.getElementById('hp-text').innerText = `${Math.floor(this.player.hp)}/${this.player.maxHp}`;
        document.getElementById('xp-bar').style.width = Math.max(0, (this.player.xp/this.player.xpNext)*100)+'%';
        document.getElementById('lvl-text').innerText = `LVL ${this.player.lvl}`;
        document.getElementById('coin-count').innerText = `üí∞ ${this.coins}`;
        document.getElementById('kill-count').innerText = `üíÄ ${this.kills}`;
    }

    collectPickup(p) {
        const msg = document.getElementById('pickup-msg');
        msg.style.opacity = 1; setTimeout(()=>msg.style.opacity=0, 1500);
        if(p.type==='potion') { this.player.hp = Math.min(this.player.maxHp, this.player.hp + 50); msg.innerText="+50 HP"; }
        if(p.type==='magnet') { this.xpOrbs.forEach(o => { o.x=this.player.x; o.y=this.player.y; }); msg.innerText="–ú–ê–ì–ù–ò–¢!"; }
        if(p.type==='chest') { this.triggerLevelUp(false, true); }
        this.updateHUD();
    }

    openShop(merchant) {
        this.state = 'PAUSED';
        this.currentMerchant = merchant; 
        const scr = document.getElementById('shop-screen');
        const cont = document.getElementById('shop-cards');
        document.getElementById('shop-coins').innerText = `–ú–æ–Ω–µ—Ç—ã: ${this.coins}`;
        cont.innerHTML = '';
        scr.style.display = 'flex';
        
        const items = [
            { name: '–õ–µ—á–µ–Ω–∏–µ', cost: 10, icon: '‚ù§Ô∏è', desc: '+50 HP', act:()=>{this.player.hp+=50;} },
            { name: '–°–∏–ª–∞', cost: 50, icon: '‚öîÔ∏è', desc: '+10% –£—Ä–æ–Ω–∞', act:()=>{this.player.weapons.forEach(w=>w.stats.dmg=Math.ceil(w.stats.dmg*1.1));} },
            { name: '–ë—Ä–æ–Ω—è', cost: 40, icon: 'üõ°Ô∏è', desc: '+2 –ë—Ä–æ–Ω–∏', act:()=>{this.player.armor+=2;} },
            { name: '–ü—Ä–æ–±–∏—Ç–∏–µ', cost: 60, icon: 'üèπ', desc: '+5 –ü—Ä–æ–±–∏—Ç–∏—è', act:()=>{this.player.armorPen+=5;} }
        ];

        items.forEach(i => {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `<span class="card-icon">${i.icon}</span><div class="card-title">${i.name}</div><div class="card-desc">${i.desc}</div><div class="cost-badge">üí∞ ${i.cost}</div>`;
            el.onclick = () => {
                if(this.coins >= i.cost) {
                    this.coins -= i.cost;
                    i.act();
                    this.closeShop(true); 
                }
            };
            cont.appendChild(el);
        });
    }

    closeShop(purchased) {
        document.getElementById('shop-screen').style.display = 'none';
        this.state = 'PLAYING';
        this.startTime = Date.now() - (this.time * 1000); 
        if(purchased && this.currentMerchant) { this.currentMerchant.dead = true; } 
        else { this.player.x += 80; }
        this.loop();
    }

    triggerLevelUp(isAltar=false, isChest=false) {
        this.state = 'PAUSED';
        const scr = document.getElementById('upgrade-screen');
        const cont = document.getElementById('upgrade-cards');
        cont.innerHTML = '';
        scr.style.display = 'flex';

        const weaponPool = [
            { id: 'paw', name: '–õ–∞–ø–∞', desc: '–£—Ä–æ–Ω –∏ –ö–î', type: 'weapon', stat1:'dmg', stat2:'cd' },
            { id: 'yarn', name: '–ö–ª—É–±–æ–∫', desc: '–°–∫–æ—Ä–æ—Å—Ç—å –∏ –ö–æ–ª-–≤–æ', type: 'weapon', stat1:'speed', stat2:'count' },
            { id: 'laser', name: '–õ–∞–∑–µ—Ä', desc: '–ë—ã—Å—Ç—Ä—ã–µ –≤—ã—Å—Ç—Ä–µ–ª—ã', type: 'weapon', stat1:'cd', stat2:'dmg' },
            { id: 'fish', name: '–ö–æ—Å—Ç—å', desc: '–ë—É–º–µ—Ä–∞–Ω–≥', type: 'weapon', stat1:'dmg', stat2:'speed' },
            { id: 'bomb_weapon', name: '–ú—è—Ç–∞', desc: '–í–∑—Ä—ã–≤', type: 'weapon', stat1:'area', stat2:'dmg' },
            { id: 'shadow_claws', name: '–¢–µ–Ω—å', desc: '–ë–ª–∏–∂–Ω–∏–π AOE', type: 'weapon', stat1:'area', stat2:'cd' },
            { id: 'water', name: '–ë—Ä—ã–∑–≥–∏', desc: '–û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ', type: 'weapon', stat1:'count', stat2:'speed' },
            { id: 'garlic', name: '–ê—É—Ä–∞', desc: '–ó–æ–Ω–∞ —É—Ä–æ–Ω–∞', type: 'weapon', stat1:'area', stat2:'dmg' }
        ];
        
        const statPool = [
            { id: 'multi', name: '–ú—É–ª—å—Ç–∏', desc: '+1 –°–Ω–∞—Ä—è–¥ –≤—Å–µ–º', type: 'stat', icon: '‚ú®' },
            { id: 'pen', name: '–û—Å—Ç—Ä–∏–µ', desc: '+5 –ü—Ä–æ–±–∏—Ç–∏—è', type: 'stat', icon: 'üî™' },
            { id: 'area', name: '–û–±–ª–∞—Å—Ç—å', desc: '+10% –†–∞–∑–º–µ—Ä–∞', type: 'stat', icon: 'üì°' },
            { id: 'heal', name: '–ï–¥–∞', desc: '+–ü–æ–ª–Ω–æ–µ HP', type: 'stat', icon: 'üçó' },
            { id: 'magnet', name: '–ú–∞–≥–Ω–∏—Ç', desc: '+50 –†–∞–¥–∏—É—Å —Å–±–æ—Ä–∞', type: 'stat', icon: 'üß≤' }
        ];

        for(let i=0; i<3; i++) {
            const isRare = Math.random() < 0.15 || isChest; 
            const r = Math.random();
            let opt;
            
            if(this.player.weapons.length < 4 && r > 0.4) {
                 opt = weaponPool[Math.floor(Math.random()*weaponPool.length)];
            } else {
                 if(Math.random() > 0.5 && this.player.weapons.length > 0) {
                     const w = this.player.weapons[Math.floor(Math.random()*this.player.weapons.length)];
                     opt = weaponPool.find(x => x.id === w.id);
                 } else {
                     opt = statPool[Math.floor(Math.random()*statPool.length)];
                 }
            }
            
            const el = document.createElement('div');
            el.className = 'card' + (isRare ? ' rare' : '') + (isChest ? ' mega' : '');
            let title = opt.name; let desc = opt.desc; let icon = opt.icon || '‚öîÔ∏è';
            if(opt.type==='weapon') {
                const wProto = new Weapon(opt.id, null); icon = wProto.icon;
                const has = this.player.weapons.find(x=>x.id===opt.id); if(!has) title += " (NEW!)";
            }
            if(isRare) { desc = "–î–≤–æ–π–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ!"; }
            if(isChest) { desc = "–¢–†–û–ô–ù–ê–Ø –°–ò–õ–ê!"; }

            el.innerHTML = `<span class="card-icon">${icon}</span><div class="card-title">${title}</div><div class="card-desc">${desc}</div>${isRare?'<div class="rare-badge">RARE</div>':''}`;
            el.onclick = () => {
                if(opt.type === 'stat') {
                    if(opt.id==='multi') this.player.globalCount += (isRare?2:1);
                    if(opt.id==='pen') this.player.armorPen += (isRare?10:5);
                    if(opt.id==='area') this.player.areaMod += (isRare?0.2:0.1);
                    if(opt.id==='heal') this.player.hp = this.player.maxHp;
                    if(opt.id==='magnet') this.player.magnetRange += (isRare?100:50);
                } else {
                    const added = this.player.addWeapon(opt.id, isChest);
                    if(added && !isChest) {
                        const w = this.player.weapons.find(x=>x.id===opt.id);
                        if(w) {
                            if(isRare) w.upgrade(opt.stat1, opt.stat2); 
                            else w.upgrade(Math.random()>0.5 ? opt.stat1 : opt.stat2);
                        }
                    }
                }
                this.player.updateWeaponUI();
                scr.style.display = 'none';
                this.state = 'PLAYING';
                this.startTime = Date.now() - (this.time * 1000);
                this.loop();
            };
            cont.appendChild(el);
        }
    }

    gameOver() {
        this.state = 'GAMEOVER';
        document.getElementById('game-over-screen').style.display='flex';
        document.getElementById('ui-layer').style.display='none';
        const mins = Math.floor(this.time/60);
        const secs = Math.floor(this.time%60);
        document.getElementById('go-stats').innerHTML = `–í—ã–∂–∏—Ç–æ: ${mins}:${secs}<br>–£–±–∏—Ç–æ: ${this.kills}`;
    }

    draw() {
        ctx.fillStyle = CONFIG.colors.grass; ctx.fillRect(0,0,canvas.width,canvas.height);
        
        ctx.save(); ctx.translate(-this.camera.x, -this.camera.y);
        
        // Bounds
        ctx.strokeStyle = '#e74c3c'; ctx.lineWidth=10; ctx.strokeRect(0,0,CONFIG.worldSize,CONFIG.worldSize);
        
        // Dense Grass Drawing
        const cx=this.camera.x, cy=this.camera.y;
        const sx=Math.floor(cx/50)*50, sy=Math.floor(cy/50)*50;
        ctx.fillStyle = CONFIG.colors.grassDark;
        for(let x=sx; x<cx+canvas.width; x+=50) {
            for(let y=sy; y<cy+canvas.height; y+=50) {
                // Deterministic noise
                if((x*y)%7 === 0) {
                    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+5,y-10); ctx.lineTo(x+10,y); ctx.fill();
                }
            }
        }
        
        // Altar (Bottom layer)
        this.superAltar.draw(ctx);

        const list = [
            ...this.obstacles.filter(o => o && o.isVisible(cx,cy)),
            ...this.merchants.filter(m => m.isVisible(cx,cy)),
            ...this.xpOrbs, ...this.pickups, ...this.coinsList,
            ...this.projectiles, ...this.enemies.filter(e => e.isVisible(cx,cy)),
            this.player, ...this.particles, ...this.texts
        ];
        
        list.sort((a,b)=>a.y-b.y);
        list.forEach(e=>e.draw(ctx));

        ctx.restore();
    }
    
    drawMinimap() {
        // RADAR MAP
        miniCtx.clearRect(0, 0, 200, 200);
        miniCtx.translate(100, 100); // Center map
        
        // Map Scale: 200px represents 2000 units radius
        const radarScale = 0.05; 
        const radarRadius = 100;

        const drawBlip = (tx, ty, color, size) => {
            let dx = (tx - this.player.x) * radarScale;
            let dy = (ty - this.player.y) * radarScale;
            const dist = Math.hypot(dx, dy);
            
            // If out of radar range
            if (dist > radarRadius - 5) {
                // Draw Arrow on edge
                const angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * (radarRadius - 10);
                dy = Math.sin(angle) * (radarRadius - 10);
                
                // Draw Arrow
                miniCtx.fillStyle = color;
                miniCtx.beginPath();
                miniCtx.moveTo(dx + Math.cos(angle)*5, dy + Math.sin(angle)*5);
                miniCtx.lineTo(dx + Math.cos(angle + 2.5)*8, dy + Math.sin(angle + 2.5)*8);
                miniCtx.lineTo(dx + Math.cos(angle - 2.5)*8, dy + Math.sin(angle - 2.5)*8);
                miniCtx.fill();
                return;
            }

            miniCtx.fillStyle = color;
            miniCtx.beginPath();
            miniCtx.arc(dx, dy, size, 0, Math.PI*2);
            miniCtx.fill();
        };

        // Draw Player (Center)
        miniCtx.fillStyle = '#fff';
        miniCtx.beginPath(); miniCtx.arc(0, 0, 3, 0, Math.PI*2); miniCtx.fill();

        // Draw Entities relative to player
        
        // Altar
        drawBlip(this.superAltar.x, this.superAltar.y, '#e056fd', 6);
        
        // Enemies (Only bosses get arrows, normal dots stay inside)
        this.enemies.forEach(e => {
            if(e.isBoss || e.isSuperBoss) drawBlip(e.x, e.y, 'red', 5);
            else {
                // Simple dot for normal enemies, no arrows
                let dx = (e.x - this.player.x) * radarScale;
                let dy = (e.y - this.player.y) * radarScale;
                if(Math.hypot(dx,dy) < radarRadius) {
                    miniCtx.fillStyle = 'rgba(231, 76, 60, 0.8)';
                    miniCtx.beginPath(); miniCtx.arc(dx, dy, 2, 0, Math.PI*2); miniCtx.fill();
                }
            }
        });

        // Pickups/Merchants
        this.merchants.forEach(m => drawBlip(m.x, m.y, '#f1c40f', 4));
        this.pickups.forEach(p => {
             let dx = (p.x - this.player.x) * radarScale;
             let dy = (p.y - this.player.y) * radarScale;
             if(Math.hypot(dx,dy) < radarRadius) {
                 miniCtx.fillStyle = 'yellow';
                 miniCtx.fillRect(dx-1, dy-1, 3, 3);
             }
        });
        
        // Obstacles (faint dots)
        this.obstacles.forEach(o => {
             if(!o) return;
             let dx = (o.x - this.player.x) * radarScale;
             let dy = (o.y - this.player.y) * radarScale;
             if(Math.hypot(dx,dy) < radarRadius) {
                 miniCtx.fillStyle = 'rgba(255,255,255,0.2)';
                 miniCtx.beginPath(); miniCtx.arc(dx, dy, 1, 0, Math.PI*2); miniCtx.fill();
             }
        });

        miniCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset
    }
}

const game = new Game();
</script>
</body>
</html>
