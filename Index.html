<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <title>–ö–æ—Ç–æ—Å—Ç—Ä–æ—Ñ–∞: –õ–µ–≥–µ–Ω–¥—ã –°–∞–¥–∞</title>
    
    <style>
        /* FONTS */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Bangers&display=swap');

        /* --- GLOBAL --- */
        body {
            margin: 0; overflow: hidden; background-color: #2d9e6d;
            font-family: 'Fredoka One', cursive, sans-serif;
            color: white; user-select: none; touch-action: none;
        }
        canvas { display: block; }
        
        /* --- UI LAYERS --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; pointer-events: auto;
        }

        /* --- VIDEO INTRO STYLES --- */
        #intro-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: none;
            justify-content: center; align-items: center; pointer-events: auto;
        }
        #intro-video { width: 100%; height: 100%; object-fit: cover; }
        #start-btn-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 201;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .big-start-btn {
            font-family: 'Bangers', cursive; font-size: 40px; color: #f1c40f;
            padding: 20px 50px; border: 5px solid #fff; background: #c0392b;
            cursor: pointer; animation: pulseBtn 1s infinite;
            text-transform: uppercase; letter-spacing: 2px;
        }
        .skip-video-btn {
            position: absolute; bottom: 30px; right: 30px;
            color: rgba(255,255,255,0.6); font-family: sans-serif; font-size: 16px;
            cursor: pointer; z-index: 202; border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px; background: rgba(0,0,0,0.5); border-radius: 20px;
        }
        @keyframes pulseBtn { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }

        /* --- HUD --- */
        .hud-top { position: absolute; top: 10px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-left { display: flex; flex-direction: column; gap: 5px; width: 220px; }
        .hud-center { text-align: center; pointer-events: auto; }
        .bar-container { background: rgba(0, 0, 0, 0.6); border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 8px; height: 22px; width: 100%; overflow: hidden; position: relative; }
        .hp-bar { background: linear-gradient(90deg, #ff4757, #ff6b81); width: 100%; height: 100%; transition: width 0.2s; }
        .xp-bar { background: linear-gradient(90deg, #2ed573, #7bed9f); width: 0%; height: 100%; transition: width 0.2s; }
        .bar-text { position: absolute; width: 100%; text-align: center; top: 2px; font-size: 12px; text-shadow: 1px 1px 1px black; z-index: 2; }
        .hud-stats { display: flex; gap: 15px; justify-content: center; background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 20px; margin-top: 5px; font-size: 16px; border: 1px solid #444; }
        #game-timer { font-size: 32px; text-shadow: 0 0 10px #000; color: #f1c40f; letter-spacing: 2px; }
        #minimap-container { position: absolute; bottom: 20px; right: 20px; width: 200px; height: 200px; background: rgba(46, 204, 113, 0.3); border: 4px solid #fff; border-radius: 50%; overflow: hidden; box-shadow: 0 0 15px rgba(0,0,0,0.5); backdrop-filter: blur(5px); }
        #minimap { width: 100%; height: 100%; display: block; }

        /* --- CARDS & BUTTONS --- */
        .cards-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 900px; max-height: 70vh; overflow-y: auto; padding: 10px; }
        .card { background: #30336b; border: 3px solid #535c68; border-radius: 12px; padding: 15px; width: 160px; cursor: pointer; text-align: center; position: relative; transition: 0.2s; }
        .card:hover { transform: translateY(-5px); border-color: #f1c40f; background: #4834d4; }
        .card.rare { border-color: #e056fd; background: #2c0e3a; box-shadow: 0 0 15px #e056fd; }
        .card.mega { border-color: #ff4757; background: #5a0e16; box-shadow: 0 0 20px #ff4757; animation: pulse 1s infinite; }
        .card-icon { font-size: 35px; margin-bottom: 8px; display: block; }
        .card-title { font-size: 15px; color: #f1c40f; margin-bottom: 5px; font-weight: bold; }
        .card-desc { font-size: 11px; color: #dff9fb; line-height: 1.3; }
        .rare-badge { position: absolute; top: -10px; right: -10px; background: #e056fd; font-size: 10px; padding: 3px 8px; border-radius: 10px; transform: rotate(15deg); }
        .btn { background: #f39c12; color: #fff; border: 3px solid #fff; padding: 12px 30px; font-size: 20px; border-radius: 30px; cursor: pointer; font-family: inherit; margin-top: 15px; box-shadow: 0 5px 0 #d35400; transition: 0.1s; }
        .btn:active { transform: translateY(5px); box-shadow: 0 0 0 #d35400; }

        /* --- JOYSTICK & NOTIFICATIONS --- */
        #joystick-area { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; pointer-events: auto; display: none; }
        .joy-base { width: 100%; height: 100%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; position: relative; }
        .joy-stick { width: 50px; height: 50px; background: #f1c40f; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #pickup-msg { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; font-weight: bold; text-shadow: 2px 2px 4px #000; color: #f1c40f; opacity: 0; pointer-events: none; }
        #altar-warning { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; color: #ff4757; text-align: center; text-shadow: 2px 2px 0 #000; display: none; animation: flash 1s infinite; }
        
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }
        @keyframes flash { 0% {opacity:1} 50% {opacity:0.5} 100% {opacity:1} }
    </style>
</head>
<body>

    <div id="intro-container">
        <div id="start-btn-overlay">
            <h1 style="font-family: 'Bangers'; font-size: 60px; color: white; margin-bottom: 20px;">–ö–û–¢–û–°–¢–†–û–§–ê</h1>
            <div class="big-start-btn" onclick="playVideo()">‚ñ∂ –°–ú–û–¢–†–ï–¢–¨ –ò–°–¢–û–†–ò–Æ</div>
            <div style="color: #ccc; margin-top: 15px; cursor: pointer; text-decoration: underline;" onclick="skipVideo()">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ –º–µ–Ω—é</div>
        </div>
        <video id="intro-video" playsinline>
            <source src="intro.mp4" type="video/mp4">
        </video>
        <div class="skip-video-btn" onclick="skipVideo()" style="display:none;" id="skip-btn-active">–ü–†–û–ü–£–°–¢–ò–¢–¨ >></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="display:none;">
        <div class="hud-top">
            <div class="hud-left">
                <div class="bar-container">
                    <div class="hp-bar" id="hp-bar"></div>
                    <div class="bar-text" id="hp-text">HP</div>
                </div>
                <div class="bar-container" style="border-color: #2ed573; margin-top: 5px;">
                    <div class="xp-bar" id="xp-bar"></div>
                    <div class="bar-text" id="lvl-text">LVL 1</div>
                </div>
                <div id="weapons-list" style="margin-top: 5px; display: flex; gap: 5px;"></div>
            </div>
            <div class="hud-center">
                <div id="game-timer">00:00</div>
                <div class="hud-stats">
                    <span id="coin-count">üí∞ 0</span>
                    <span id="kill-count">üíÄ 0</span>
                </div>
            </div>
            <div style="width: 50px;"></div>
        </div>
        <div id="minimap-container"><canvas id="minimap"></canvas></div>
        <div id="pickup-msg"></div>
        <div id="altar-warning">–ê–õ–¢–ê–†–¨ –ó–ê–ü–ï–ß–ê–¢–ê–ù<br>–ñ–¥–∏—Ç–µ 10-–π –º–∏–Ω—É—Ç—ã...</div>
        <div id="joystick-area"><div class="joy-base"><div class="joy-stick" id="joy-stick"></div></div></div>
    </div>

    <div id="class-screen" class="screen" style="display: none;">
        <h1>–í–´–ë–û–† –ì–ï–†–û–Ø</h1>
        <div class="cards-container">
            <div class="card" onclick="game.start('mainecoon')"><span class="card-icon">ü¶Å</span><div class="card-title">–ú–µ–π–Ω-–∫—É–Ω</div><div class="card-desc">–¢–∞–Ω–∫. –ú–Ω–æ–≥–æ HP.<br>–û—Ä—É–∂–∏–µ: –õ–∞–ø–∞</div></div>
            <div class="card" onclick="game.start('tabby')"><span class="card-icon">üòº</span><div class="card-title">–ü–æ–ª–æ—Å–∞—Ç—ã–π</div><div class="card-desc">–ë–∞–ª–∞–Ω—Å.<br>–û—Ä—É–∂–∏–µ: –ö–ª—É–±–æ–∫</div></div>
            <div class="card" onclick="game.start('black')"><span class="card-icon">üêà‚Äç‚¨õ</span><div class="card-title">–ß–µ—Ä–Ω—ã–π</div><div class="card-desc">–£–¥–∞—á–∞ –∏ –ö—Ä–∏—Ç.<br>–û—Ä—É–∂–∏–µ: –ö–æ–≥—Ç–∏</div></div>
            <div class="card" onclick="game.start('siamese')"><span class="card-icon">‚ú®</span><div class="card-title">–°–∏–∞–º—Å–∫–∏–π</div><div class="card-desc">–ú–∞–≥. –û–±–ª–∞—Å—Ç—å +20%.<br>–û—Ä—É–∂–∏–µ: –ê—É—Ä–∞</div></div>
            <div class="card" onclick="game.start('siberian')"><span class="card-icon">‚ùÑÔ∏è</span><div class="card-title">–°–∏–±–∏—Ä—Å–∫–∏–π</div><div class="card-desc">–ú–æ—Ä–æ–∑. –ö–æ–Ω—Ç—Ä–æ–ª—å.<br>–û—Ä—É–∂–∏–µ: –í—å—é–≥–∞</div></div>
            <div class="card" onclick="game.start('british')"><span class="card-icon">‚òï</span><div class="card-title">–ë—Ä–∏—Ç–∞–Ω–µ—Ü</div><div class="card-desc">–ê—Ä–∏—Å—Ç–æ–∫—Ä–∞—Ç.<br>–û—Ä—É–∂–∏–µ: –ß–∞–π (AoE)</div></div>
            <div class="card" onclick="game.start('munchkin')"><span class="card-icon">üó°Ô∏è</span><div class="card-title">–ú–∞–Ω—á–∫–∏–Ω</div><div class="card-desc">–ë–ª–∏–∂–Ω–∏–π –±–æ–π.<br>–û—Ä—É–∂–∏–µ: –ö–æ—Ä—Ç–∏–∫</div></div>
        </div>
    </div>

    <div id="upgrade-screen" class="screen" style="display: none;">
        <h1 id="upg-title">LEVEL UP!</h1>
        <div class="cards-container" id="upgrade-cards"></div>
    </div>

    <div id="shop-screen" class="screen" style="display: none;">
        <h1 style="color:#f1c40f">–õ–∞–≤–∫–∞ –ï–Ω–æ—Ç–∞</h1>
        <h2 id="shop-coins">–í–∞—à–∏ –º–æ–Ω–µ—Ç—ã: 0</h2>
        <div class="cards-container" id="shop-cards"></div>
        <button class="btn" onclick="game.closeShop(false)">–£–π—Ç–∏</button>
    </div>

    <div id="game-over-screen" class="screen" style="display: none;">
        <h1 id="go-title">–ö–û–ù–ï–¶ –ò–ì–†–´</h1>
        <h2 id="go-stats">...</h2>
        <button class="btn" onclick="game.resetGame()">–ú–µ–Ω—é</button>
    </div>

<script>
// --- TELEGRAM INIT ---
if(window.Telegram && window.Telegram.WebApp) {
    window.Telegram.WebApp.ready();
    window.Telegram.WebApp.expand();
}

// --- VIDEO INTRO LOGIC ---
const videoSeenKey = 'cat_rpg_video_final_v1'; // –ù–æ–≤—ã–π –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
const hasSeenVideo = localStorage.getItem(videoSeenKey);
const introContainer = document.getElementById('intro-container');
const videoElement = document.getElementById('intro-video');
const startBtnOverlay = document.getElementById('start-btn-overlay');
const skipBtnActive = document.getElementById('skip-btn-active');

// –ü–†–û–í–ï–†–ö–ê –û–®–ò–ë–û–ö –í–ò–î–ï–û
videoElement.onerror = function() {
    alert("–û–®–ò–ë–ö–ê: –í–∏–¥–µ–æ 'intro.mp4' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è!\n\n1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ —Ñ–∞–π–ª –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ—á–Ω–æ 'intro.mp4'\n2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, –Ω–µ—Ç –ª–∏ –¥–≤–æ–π–Ω–æ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è (intro.mp4.mp4)\n3. –í–∏–¥–µ–æ –¥–æ–ª–∂–Ω–æ –ª–µ–∂–∞—Ç—å –≤ –¢–û–ô –ñ–ï –ø–∞–ø–∫–µ, —á—Ç–æ –∏ index.html");
    skipVideo(); // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ - —Å—Ä–∞–∑—É –ø—É—Å–∫–∞–µ–º –≤ –∏–≥—Ä—É
};

// –õ–æ–≥–∏–∫–∞ –ø–æ–∫–∞–∑–∞
if (!hasSeenVideo) {
    introContainer.style.display = 'flex';
} else {
    document.getElementById('class-screen').style.display = 'flex';
}

function playVideo() {
    startBtnOverlay.style.display = 'none';
    skipBtnActive.style.display = 'block';
    
    // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç—å
    var playPromise = videoElement.play();

    if (playPromise !== undefined) {
        playPromise.then(_ => {
            // –í–∏–¥–µ–æ –Ω–∞—á–∞–ª–æ—Å—å
            console.log("Video started");
        })
        .catch(error => {
            // –ë—Ä–∞—É–∑–µ—Ä –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –∞–≤—Ç–æ–ø–ª–µ–π
            console.log("Autoplay prevented");
            // –ü—Ä–æ–±—É–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–æ –∑–≤—É–∫–æ–º –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
            videoElement.muted = false;
            videoElement.play();
        });
    }
}

function skipVideo() {
    videoElement.pause();
    introContainer.style.display = 'none';
    localStorage.setItem(videoSeenKey, 'true');
    document.getElementById('class-screen').style.display = 'flex';
}

// –ö–æ–≥–¥–∞ –≤–∏–¥–µ–æ –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å - –∏–¥–µ–º –≤ –º–µ–Ω—é
videoElement.onended = function() {
    skipVideo();
};

// --- CONFIG & ENGINE (–ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
const CONFIG = { worldSize: 50000, colors: { grass: '#2d9e6d', grassDark: '#268b5e' } };
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.Telegram && window.Telegram.WebApp.initData);

function resize() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    miniCanvas.width = 200; miniCanvas.height = 200;
    if(isMobile) document.getElementById('joystick-area').style.display = 'block';
}
window.addEventListener('resize', resize); resize();

const input = { keys: {}, joystick: { x: 0, y: 0, active: false } };
window.addEventListener('keydown', e => input.keys[e.code] = true);
window.addEventListener('keyup', e => input.keys[e.code] = false);

const joyBase = document.querySelector('.joy-base');
const joyStick = document.getElementById('joy-stick');
let joyTouchId = null;

joyBase.addEventListener('touchstart', e => { e.preventDefault(); joyTouchId = e.changedTouches[0].identifier; input.joystick.active = true; }, {passive:false});
joyBase.addEventListener('touchmove', e => {
    e.preventDefault(); const touch = Array.from(e.changedTouches).find(t => t.identifier === joyTouchId);
    if(!touch) return;
    const rect = joyBase.getBoundingClientRect(); const maxDist = rect.width/2 - 25;
    let dx = touch.clientX - (rect.left + rect.width/2); let dy = touch.clientY - (rect.top + rect.height/2);
    const dist = Math.hypot(dx, dy);
    if(dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
    joyStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    input.joystick.x = dx / maxDist; input.joystick.y = dy / maxDist;
}, {passive:false});
const endJoy = (e) => { e.preventDefault(); joyTouchId = null; input.joystick.active = false; input.joystick.x=0; input.joystick.y=0; joyStick.style.transform = `translate(-50%, -50%)`; };
joyBase.addEventListener('touchend', endJoy); joyBase.addEventListener('touchcancel', endJoy);

function drawCircle(ctx, x, y, r, color, stroke=null) {
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle=color; ctx.fill();
    if(stroke) { ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.stroke(); }
}

class Camera {
    constructor() { this.x = 0; this.y = 0; }
    follow(t) {
        this.x += (t.x - canvas.width/2 - this.x) * 0.1; this.y += (t.y - canvas.height/2 - this.y) * 0.1;
        this.x = Math.max(0, Math.min(this.x, CONFIG.worldSize - canvas.width)); this.y = Math.max(0, Math.min(this.y, CONFIG.worldSize - canvas.height));
    }
}

class Entity {
    constructor(x, y, r) { this.x = x; this.y = y; this.r = r; this.dead = false; }
    isVisible(cx, cy) { return this.x+this.r+50 > cx && this.x-this.r-50 < cx+canvas.width && this.y+this.r+50 > cy && this.y-this.r-50 < cy+canvas.height; }
    resolveObstacle(o) {
        const dx = this.x - o.x; const dy = this.y - o.y; const dist = Math.hypot(dx, dy); const minDist = this.r + o.r;
        if (dist < minDist) { const angle = Math.atan2(dy, dx); const push = minDist - dist; this.x += Math.cos(angle) * push; this.y += Math.sin(angle) * push; }
    }
}

class XPOrb extends Entity {
    constructor(x, y, val) { super(x, y, 4); this.val = val; this.magnetized = false; }
    update() {
        const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
        if (this.magnetized || dist < game.player.magnetRange) {
            const ang = Math.atan2(game.player.y - this.y, game.player.x - this.x); const speed = this.magnetized ? 15 : 8;
            this.x += Math.cos(ang) * speed; this.y += Math.sin(ang) * speed;
            if (Math.hypot(game.player.x - this.x, game.player.y - this.y) < 20) { this.dead = true; game.addXP(this.val); }
        }
    }
    draw(ctx) { ctx.fillStyle='#2ed573'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); }
}

class Obstacle extends Entity {
    constructor(x, y, type) { super(x, y, type==='tree'?35:30); this.type = type; }
    draw(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; drawCircle(ctx, this.x+5, this.y+5, this.r, null);
        if(this.type === 'tree') { drawCircle(ctx, this.x, this.y, 15, '#5d4037'); drawCircle(ctx, this.x, this.y-25, 45, '#1e8449', '#145a32'); drawCircle(ctx, this.x-15, this.y-40, 15, '#2ecc71'); }
        else { ctx.fillStyle = '#7f8c8d'; ctx.strokeStyle = '#535c68'; ctx.lineWidth = 3; ctx.beginPath(); ctx.roundRect(this.x-30, this.y-25, 60, 50, 10); ctx.fill(); ctx.stroke(); drawCircle(ctx, this.x-10, this.y-10, 5, '#95a5a6'); }
    }
}

class BuffAltar extends Entity {
    constructor(type) {
        super(Math.random()*(CONFIG.worldSize-500)+250, Math.random()*(CONFIG.worldSize-500)+250, 80);
        this.type = type; this.active = true; this.progress = 0; this.maxProgress = 300;
        if(type==='vamp') { this.color = '#e74c3c'; } if(type==='chrono') { this.color = '#0984e3'; } if(type==='titan') { this.color = '#2ecc71'; }
    }
    update() {
        if(!this.active) return;
        const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
        if(dist < this.r) { this.progress += 1; if(this.progress >= this.maxProgress) { this.activateBuff(); this.active = false; } }
        else { this.progress = Math.max(0, this.progress - 0.5); }
    }
    activateBuff() {
        const msg = document.getElementById('pickup-msg'); msg.style.opacity = 1; setTimeout(()=>msg.style.opacity=0, 3000);
        if(this.type === 'vamp') { game.player.vampirism = true; msg.innerText = "–î–ê–† –í–ê–ú–ü–ò–†–ê!"; }
        if(this.type === 'chrono') { game.player.weapons.forEach(w => w.stats.maxCd *= 0.8); game.player.cooldownReduction = 0.8; msg.innerText = "–í–†–ï–ú–Ø –£–°–ö–û–†–ï–ù–û!"; }
        if(this.type === 'titan') { game.player.sizeMult = 1.3; msg.innerText = "–°–ò–õ–ê –¢–ò–¢–ê–ù–ê!"; }
        game.createExplosion(this.x, this.y, 200, 0, this.color);
    }
    draw(ctx) {
        if(!this.active) return;
        ctx.strokeStyle = this.color; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 0.3; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.r * (this.progress/this.maxProgress), 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#fff'; ctx.font = '30px serif'; ctx.fillText('‚ö°', this.x-10, this.y+10);
    }
}

class SuperAltar extends Entity {
    constructor() { super(Math.random()*(CONFIG.worldSize-1000)+500, Math.random()*(CONFIG.worldSize-1000)+500, 200); this.active = true; }
    update() {
        if(!this.active) return;
        const d = Math.hypot(game.player.x - this.x, game.player.y - this.y);
        if (d > this.r + 200) { document.getElementById('altar-warning').style.display = 'none'; }
        else if (d < this.r + 50 && game.time < 600) { const w = document.getElementById('altar-warning'); w.style.display = 'block'; w.innerText = `–ü–ï–ß–ê–¢–¨: ${Math.ceil(600 - game.time)} —Å–µ–∫`; }
        if (d < this.r && game.time >= 600) { this.active = false; game.spawnSuperBoss(this.x, this.y); document.getElementById('altar-warning').style.display = 'none'; }
    }
    draw(ctx) {
        if(!this.active) return;
        ctx.fillStyle = 'rgba(75, 0, 130, 0.3)'; ctx.beginPath(); ctx.arc(this.x, this.y, 400, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = game.time >= 600 ? '#f0f' : '#555'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
        ctx.font = '30px serif'; ctx.fillStyle='#fff'; ctx.fillText('‚ò†Ô∏è', this.x-15, this.y+10);
    }
}

class Merchant extends Entity {
    constructor() { super(Math.random()*(CONFIG.worldSize-500)+250, Math.random()*(CONFIG.worldSize-500)+250, 40); }
    update() { if(Math.hypot(game.player.x - this.x, game.player.y - this.y) < this.r + 30) { game.openShop(this); } }
    draw(ctx) {
        drawCircle(ctx, this.x, this.y, 30, '#95a5a6', '#2c3e50'); drawCircle(ctx, this.x, this.y-5, 20, '#fff'); 
        drawCircle(ctx, this.x-8, this.y-5, 3, '#000'); drawCircle(ctx, this.x+8, this.y-5, 3, '#000'); ctx.fillStyle='#f1c40f'; ctx.font='20px sans-serif'; ctx.fillText('üõí', this.x-12, this.y-35);
    }
}

class Enemy extends Entity {
    constructor(isBoss=false, isSuperBoss=false, x, y) {
        if(!x) {
            const angle = Math.random()*Math.PI*2; const dist = 900;
            x = Math.max(100, Math.min(CONFIG.worldSize-100, game.player.x + Math.cos(angle)*dist)); y = Math.max(100, Math.min(CONFIG.worldSize-100, game.player.y + Math.sin(angle)*dist));
        }
        super(x, y, isBoss?60:20); this.isBoss = isBoss; this.isSuperBoss = isSuperBoss;
        
        if(isSuperBoss) {
            this.r = 100; this.type = 'lich'; this.maxHp = 50000; this.hp = this.maxHp; this.xp = 10000; this.dmg = 200; this.speed = 2.4; this.armor = 50;
        } else {
            const mins = game.time / 60; const hpMult = 1 + (mins * 1.5); const dmgMult = 1 + (mins * 0.5); this.armor = Math.floor(mins * 3);
            let earlyGameBuff = 1.0; if (game.time < 60) earlyGameBuff = 2.5; 
            if(isBoss) { this.type = 'demon'; this.maxHp = 3000 * hpMult; this.hp = this.maxHp; this.xp = 1000; this.dmg = 40 * dmgMult; this.speed = 1.9; this.armor += 10; }
            else {
                const r = Math.random();
                if(r < 0.3) { this.type='slime'; this.maxHp=30*hpMult*earlyGameBuff; this.speed=1.3; this.dmg=8*dmgMult; this.xp=5; }
                else if(r < 0.6) { this.type='bat'; this.maxHp=20*hpMult*earlyGameBuff; this.speed=2.1; this.dmg=5*dmgMult; this.xp=5; }
                else if(r < 0.8) { this.type='ghost'; this.maxHp=50*hpMult*earlyGameBuff; this.speed=1.0; this.dmg=15*dmgMult; this.xp=10; this.armor+=5;}
                else { this.type='spider'; this.maxHp=80*hpMult*earlyGameBuff; this.speed=1.0; this.dmg=12*dmgMult; this.xp=15; this.armor+=2;}
                this.hp = this.maxHp;
            }
        }
    }
    update() {
        const ang = Math.atan2(game.player.y-this.y, game.player.x-this.x);
        this.x += Math.cos(ang)*this.speed; this.y += Math.sin(ang)*this.speed;
        if(this.isBoss || this.isSuperBoss) {
            game.obstacles.forEach((o, index) => { if(o && Math.hypot(this.x-o.x, this.y-o.y) < this.r + o.r) { game.particles.push(new Particle(o.x, o.y, '#7f8c8d')); delete game.obstacles[index]; } });
        } else { game.obstacles.forEach(o => { if(o && this.isVisible(game.camera.x, game.camera.y)) this.resolveObstacle(o); }); }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        if(this.isBoss || this.isSuperBoss) { ctx.fillStyle='red'; ctx.fillRect(-50, -this.r-20, 100, 10); ctx.fillStyle='#0f0'; ctx.fillRect(-50, -this.r-20, 100 * (Math.max(0,this.hp)/this.maxHp), 10); }
        if(this.isSuperBoss) {
             drawCircle(ctx, 0, 0, 80, '#2c0e3a', '#e056fd'); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(-20, -10, 10, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20, -10, 10, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(-20, -10, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20, -10, 3, 0, Math.PI*2); ctx.fill();
        } else if(this.type === 'slime') {
            ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(0,0,20,Math.PI, 0); ctx.fill(); ctx.fillRect(-20,0,40,10); ctx.fillStyle = '#000'; drawCircle(ctx, -5, -5, 3, '#000'); drawCircle(ctx, 5, -5, 3, '#000');
        } else if (this.type === 'bat') {
            ctx.fillStyle = '#8e44ad'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-20,-15); ctx.lineTo(-10,5); ctx.fill(); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20,-15); ctx.lineTo(10,5); ctx.fill(); drawCircle(ctx, 0, 0, 10, '#34495e');
        } else if (this.type === 'ghost') {
            ctx.fillStyle = 'rgba(236, 240, 241, 0.8)'; ctx.beginPath(); ctx.arc(0,-10,15,Math.PI,0); ctx.lineTo(15,20); ctx.lineTo(0,10); ctx.lineTo(-15,20); ctx.fill(); ctx.fillStyle = '#000'; drawCircle(ctx, -6, -10, 2, '#000'); drawCircle(ctx, 6, -10, 2, '#000');
        } else if (this.type === 'spider') {
            ctx.strokeStyle = '#2c3e50'; ctx.lineWidth=2; for(let i=0; i<4; i++) { ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(i)*25, Math.sin(i)*25); ctx.stroke(); } drawCircle(ctx, 0, 0, 12, '#2c3e50'); ctx.fillStyle='red'; drawCircle(ctx, 0, -5, 2, 'red');
        } else if (this.type === 'demon') {
            drawCircle(ctx, 0, 0, 50, '#c0392b', '#000'); ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.moveTo(-20,-30); ctx.lineTo(-40,-60); ctx.lineTo(-10,-40); ctx.fill(); ctx.beginPath(); ctx.moveTo(20,-30); ctx.lineTo(40,-60); ctx.lineTo(10,-40); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(-30,-10); ctx.lineTo(-10,-10); ctx.lineTo(-20, 10); ctx.fill(); ctx.beginPath(); ctx.moveTo(30,-10); ctx.lineTo(10,-10); ctx.lineTo(20, 10); ctx.fill();
        }
        ctx.restore();
    }
}

class Player extends Entity {
    constructor(type) {
        super(CONFIG.worldSize/2, CONFIG.worldSize/2, 20);
        this.type = type; this.hp = 100; this.maxHp = 100; this.xp = 0; this.xpNext = 20; this.lvl = 1; this.speed = 4;
        this.weapons = []; this.facing = 1; this.globalCount = 0; this.armorPen = 0; this.areaMod = 1.0; this.armor = 0; this.regen = 0; this.magnetRange = 150;
        this.vampirism = false; this.cooldownReduction = 1.0; this.sizeMult = 1.0;

        if(type==='mainecoon') { this.maxHp=200; this.hp=200; this.speed=2.9; this.addWeapon('paw'); }
        if(type==='tabby') { this.speed=3.4; this.addWeapon('yarn'); }
        if(type==='black') { this.critChance = 0.2; this.speed=3.4; this.addWeapon('shadow_claws'); }
        if(type==='siamese') { this.areaMod = 1.2; this.speed=3.4; this.addWeapon('garlic'); }
        if(type==='ragdoll') { this.armor = 5; this.maxHp=150; this.hp=150; this.speed=2.5; this.addWeapon('bomb_weapon'); }
        if(type==='persian') { this.regen = 1; this.speed=2.1; this.addWeapon('fish'); }
        if(type==='siberian') { this.maxHp=120; this.hp=120; this.speed=3.8; this.addWeapon('blizzard'); }
        if(type==='british') { this.maxHp=140; this.hp=140; this.speed=3.0; this.armor=2; this.addWeapon('tea'); }
        if(type==='munchkin') { this.r=15; this.maxHp=90; this.hp=90; this.speed=4.5; this.addWeapon('dagger'); }
    }
    addWeapon(id, isMega=false) {
        const existing = this.weapons.find(w => w.id === id);
        if(!existing && this.weapons.length >= 4) return false;
        if(existing) { if(isMega) existing.megaUpgrade(); else existing.upgrade(); }
        else { const w = new Weapon(id, this); if(isMega) w.megaUpgrade(); this.weapons.push(w); this.updateWeaponUI(); }
        return true;
    }
    updateWeaponUI() {
        const list = document.getElementById('weapons-list'); list.innerHTML = '';
        this.weapons.forEach(w => { const el = document.createElement('div'); el.innerHTML = w.icon || '‚ùì'; el.style.cssText = 'width:25px;height:25px;background:#333;border-radius:50%;text-align:center;font-size:16px;line-height:25px;border:1px solid #fff;'; list.appendChild(el); });
    }
    update() {
        if(this.regen > 0 && Math.random() < 0.01) this.hp = Math.min(this.maxHp, this.hp + this.regen);
        let dx=0, dy=0;
        if(input.joystick.active) { dx=input.joystick.x; dy=input.joystick.y; }
        else { if(input.keys['KeyW'] || input.keys['ArrowUp']) dy=-1; if(input.keys['KeyS'] || input.keys['ArrowDown']) dy=1; if(input.keys['KeyA'] || input.keys['ArrowLeft']) dx=-1; if(input.keys['KeyD'] || input.keys['ArrowRight']) dx=1; }
        if(!input.joystick.active && (dx||dy)) { const l=Math.hypot(dx,dy); dx/=l; dy/=l; }
        this.x += dx*this.speed; this.y += dy*this.speed;
        game.obstacles.forEach(o => { if(o) this.resolveObstacle(o); });
        this.x = Math.max(50, Math.min(CONFIG.worldSize-50, this.x)); this.y = Math.max(50, Math.min(CONFIG.worldSize-50, this.y));
        if(dx>0) this.facing=1; if(dx<0) this.facing=-1;
        this.weapons.forEach(w => w.update());
    }
    draw(ctx) {
        this.weapons.forEach(w => w.draw(ctx));
        ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
        let color = '#fff';
        if(this.type==='mainecoon') color='#5d4037'; if(this.type==='black') color='#2d3436'; if(this.type==='siamese') color='#f5f6fa'; if(this.type==='persian') color='#ecf0f1'; if(this.type==='siberian') color='#dfe6e9'; if(this.type==='british') color='#636e72'; if(this.type==='munchkin') color='#e17055';
        ctx.scale(this.sizeMult, this.sizeMult);
        drawCircle(ctx, 0, 5, 20, color, '#000'); drawCircle(ctx, 0, -10, 16, color, '#000'); 
        ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(-10,-20); ctx.lineTo(-15,-35); ctx.lineTo(-5,-25); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10,-20); ctx.lineTo(15,-35); ctx.lineTo(5,-25); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#fff'; drawCircle(ctx, 5, -10, 4, '#fff'); drawCircle(ctx, -5, -10, 4, '#fff');
        ctx.fillStyle='#000'; drawCircle(ctx, 5, -10, 2, '#000'); drawCircle(ctx, -5, -10, 2, '#000');
        ctx.restore();
    }
}

class Weapon {
    constructor(id, owner) {
        this.id = id; this.owner = owner; this.level = 1; this.cd = 0;
        this.stats = { dmg: 10, speed: 1, size: 1, maxCd: 60, count: 1, area: 100, duration: 60 };
        this.setup(); this.stats.maxCd *= owner.cooldownReduction;
    }
    setup() {
        if(this.id==='paw') { this.name="–õ–∞–ø–∞"; this.icon="üêæ"; this.stats={dmg:25, maxCd:40, speed:8, count:1, range:300}; }
        if(this.id==='yarn') { this.name="–ö–ª—É–±–æ–∫"; this.icon="üß∂"; this.stats={dmg:12, maxCd:0, speed:0.04, count:1, dist:80, size:10}; }
        if(this.id==='blizzard') { this.name="–í—å—é–≥–∞"; this.icon="‚ùÑÔ∏è"; this.stats={dmg:8, maxCd:10, count:1, speed:1.5}; }
        if(this.id==='tea') { this.name="–ß–∞–π"; this.icon="‚òï"; this.stats={dmg:15, maxCd:90, speed:5, area: 80, duration: 200}; }
        if(this.id==='dagger') { this.name="–ö–æ—Ä—Ç–∏–∫"; this.icon="üó°Ô∏è"; this.stats={dmg:20, maxCd:25, range:70, count:1}; }
        if(this.id==='fish') { this.name="–ö–æ—Å—Ç—å"; this.icon="üêü"; this.stats={dmg:40, maxCd:70, speed:6, count:1}; }
        if(this.id==='shadow_claws') { this.name="–¢–µ–Ω—å"; this.icon="üåë"; this.stats={dmg:60, maxCd:50, range:100, area: 80}; }
        if(this.id==='bomb_weapon') { this.name="–ú—è—Ç–∞"; this.icon="üí£"; this.stats={dmg:100, maxCd:150, area:150}; }
        if(this.id==='garlic') { this.name="–ê—É—Ä–∞"; this.icon="‚ú®"; this.stats={dmg:3, maxCd:15, area:90}; }
    }
    upgrade(stat1, stat2) {
        this.level++;
        const applyStat = (type) => {
            if(type === 'dmg') this.stats.dmg = Math.ceil(this.stats.dmg * 1.2);
            if(type === 'cd') this.stats.maxCd *= 0.85;
            if(type === 'count') this.stats.count += 1;
            if(type === 'area') this.stats.area *= 1.2;
            if(type === 'speed') this.stats.speed *= 1.1;
        };
        if(!stat1) { this.stats.dmg *= 1.2; return; }
        applyStat(stat1); if(stat2) applyStat(stat2);
    }
    megaUpgrade() { this.level+=3; this.stats.dmg*=2; this.stats.count+=2; }
    
    update() {
        if(this.cd > 0) this.cd--;
        const totalCount = this.stats.count + this.owner.globalCount;
        const areaMult = this.owner.areaMod * this.owner.sizeMult;
        const owner = this.owner;

        if(this.id === 'paw' && this.cd <= 0) {
            const t = game.getNearestEnemy(owner, this.stats.range);
            if(t) { for(let i=0; i<totalCount; i++) game.projectiles.push(new Projectile(owner.x, owner.y, t, 'paw', this.stats, (i-(totalCount-1)/2)*0.2)); this.cd = this.stats.maxCd; }
        }
        if(this.id === 'blizzard' && this.cd <= 0) {
             const angle = (Date.now() / 500) % (Math.PI*2);
             for(let i=0; i<totalCount; i++) {
                 const a = angle + (i * (Math.PI*2/totalCount));
                 const p = new Projectile(owner.x, owner.y, {x: owner.x+Math.cos(a)*100, y: owner.y+Math.sin(a)*100}, 'shard', this.stats, 0);
                 game.projectiles.push(p);
             }
             this.cd = this.stats.maxCd;
        }
        if(this.id === 'tea' && this.cd <= 0) {
            const t = game.getNearestEnemy(owner, 400);
            if(t) { game.projectiles.push(new Projectile(owner.x, owner.y, t, 'tea_cup', this.stats, 0)); this.cd = this.stats.maxCd; }
        }
        if(this.id === 'dagger' && this.cd <= 0) {
             const t = game.getNearestEnemy(owner, 150);
             let angle = owner.facing === 1 ? 0 : Math.PI;
             if (t) { angle = Math.atan2(t.y - owner.y, t.x - owner.x); }
             for(let i=0; i<totalCount; i++) { setTimeout(() => { game.projectiles.push(new Projectile(owner.x, owner.y, null, 'dagger_slash', this.stats, angle)); }, i * 100); }
             this.cd = this.stats.maxCd;
        }
        if(this.id === 'fish' && this.cd <= 0) {
             const t = game.getNearestEnemy(owner, 500); if(t) { game.projectiles.push(new Projectile(owner.x, owner.y, t, 'fish', this.stats, 0)); this.cd = this.stats.maxCd; }
        }
        if(this.id === 'bomb_weapon' && this.cd <= 0) {
            game.projectiles.push(new Projectile(owner.x, owner.y, null, 'bomb', { ...this.stats, area: this.stats.area*areaMult })); this.cd = this.stats.maxCd;
        }
        if(this.id === 'shadow_claws' && this.cd <= 0) {
            const angle = owner.facing === 1 ? 0 : Math.PI;
            game.createExplosion(owner.x + Math.cos(angle)*50, owner.y, this.stats.area*areaMult, this.stats.dmg, '#2d3436'); this.cd = this.stats.maxCd;
        }
        if(this.id === 'garlic' && this.cd <= 0) {
            game.enemies.forEach(e => { if(Math.hypot(e.x-owner.x, e.y-owner.y) < this.stats.area * areaMult) game.damageEnemy(e, this.stats.dmg); }); this.cd = this.stats.maxCd;
        }
    }
    
    draw(ctx) {
        const totalCount = this.stats.count + this.owner.globalCount;
        if(this.id === 'yarn') {
            const step = (Math.PI*2)/totalCount; const now = Date.now()*0.001*this.stats.speed*10;
            for(let i=0; i<totalCount; i++) {
                const ang = now + i*step; const bx = this.owner.x + Math.cos(ang)*this.stats.dist; const by = this.owner.y + Math.sin(ang)*this.stats.dist;
                drawCircle(ctx, bx, by, this.stats.size, '#e74c3c'); ctx.strokeStyle='rgba(231,76,60,0.5)'; ctx.beginPath(); ctx.moveTo(this.owner.x, this.owner.y); ctx.lineTo(bx, by); ctx.stroke();
                game.enemies.forEach(e => { if(Math.hypot(bx-e.x, by-e.y) < this.stats.size+e.r) game.damageEnemy(e, this.stats.dmg); });
            }
        }
        if(this.id === 'garlic') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; ctx.beginPath(); ctx.arc(this.owner.x, this.owner.y, this.stats.area * this.owner.areaMod * this.owner.sizeMult, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth=1; ctx.stroke();
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, target, type, stats, extraData=0) {
        super(x, y, 10); this.type = type; this.dmg = stats.dmg; this.speed = stats.speed; this.target = target; this.timer = 120; this.extra = extraData;
        if(game.player.sizeMult > 1) this.r *= game.player.sizeMult;
        if(type==='bomb') { this.timer = 60; this.area = stats.area * game.player.sizeMult; }
        else if (type==='tea_puddle') { this.timer = stats.duration || 200; this.r = stats.area * game.player.sizeMult; }
        else if (type==='dagger_slash') { this.timer = 10; this.angle = extraData; }
        else {
            const ang = Math.atan2(target.y - y, target.x - x) + extraData;
            this.vx = Math.cos(ang)*this.speed; this.vy = Math.sin(ang)*this.speed; this.angle = ang;
            if(type==='fish') { this.returnState = 0; this.timer=200; }
        }
    }
    update() {
        if(this.type === 'bomb') { this.timer--; if(this.timer <= 0) { this.dead = true; game.createExplosion(this.x, this.y, this.area, this.dmg, '#2ecc71'); } return; }
        if(this.type === 'tea_puddle') { this.timer--; if(this.timer<=0) this.dead=true; if(this.timer % 20 === 0) { game.enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < this.r + e.r) game.damageEnemy(e, this.dmg); }); } return; }
        if(this.type === 'dagger_slash') { this.timer--; this.x = game.player.x + (Math.cos(this.angle) * 60 * game.player.sizeMult); this.y = game.player.y + (Math.sin(this.angle) * 60 * game.player.sizeMult); if(this.timer<=0) this.dead=true; return; }
        if(this.type === 'tea_cup') {
            this.timer--; this.x += this.vx; this.y += this.vy;
            if(this.timer <= 0 || (this.target && Math.hypot(this.target.x-this.x, this.target.y-this.y) < 20)) { this.dead = true; game.projectiles.push(new Projectile(this.x, this.y, null, 'tea_puddle', {dmg: this.dmg, area: 60, duration: 200})); } return;
        }
        if(this.type === 'fish') {
            this.timer--; if(this.timer < 160 && this.returnState === 0) { this.returnState = 1; }
            if(this.returnState === 1) {
                const ang = Math.atan2(game.player.y - this.y, game.player.x - this.x); this.vx += Math.cos(ang) * 0.5; this.vy += Math.sin(ang) * 0.5;
                const l = Math.hypot(this.vx, this.vy); if(l > this.speed) { this.vx = (this.vx/l)*this.speed; this.vy = (this.vy/l)*this.speed; }
                if(Math.hypot(game.player.x - this.x, game.player.y - this.y) < 20) this.dead = true;
            }
        }
        this.x += this.vx; this.y += this.vy; if(this.type !== 'fish') { this.timer--; if(this.timer <= 0) this.dead = true; }
    }
    draw(ctx) {
        ctx.save();
        if (game.player.sizeMult > 1) { ctx.translate(this.x, this.y); ctx.scale(game.player.sizeMult, game.player.sizeMult); ctx.translate(-this.x, -this.y); }
        if(this.type === 'bomb') { drawCircle(ctx, this.x, this.y, 10, '#e74c3c'); if(Math.floor(Date.now()/100)%2===0) ctx.fillStyle='#fff'; else ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(this.x, this.y-5, 3, 0, Math.PI*2); ctx.fill(); ctx.restore(); return; }
        if(this.type === 'tea_puddle') { ctx.fillStyle = 'rgba(160, 82, 45, 0.5)'; ctx.beginPath(); ctx.ellipse(this.x, this.y, this.r, this.r*0.6, 0, 0, Math.PI*2); ctx.fill(); ctx.restore(); return; }
        if(this.type === 'dagger_slash') {
             ctx.save(); ctx.translate(game.player.x, game.player.y); ctx.rotate(this.angle); 
             ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(80, 0); ctx.lineTo(10, 5); ctx.fill();
             ctx.restore(); ctx.restore(); return;
        }
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        if(this.type==='paw') drawCircle(ctx, 0, 0, 8, '#00f0ff'); else if (this.type==='shard') { ctx.fillStyle='#74b9ff'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,-5); ctx.lineTo(-10,5); ctx.fill(); } else if (this.type==='tea_cup') { ctx.fillStyle='#fff'; ctx.fillRect(-5,-5,10,8); ctx.fillStyle='#a0522d'; ctx.fillRect(-3,-5,6,6); } else if (this.type==='fish') { ctx.fillStyle='#fff'; ctx.font='20px serif'; ctx.fillText('üêü', -10, 5); }
        ctx.restore(); ctx.restore();
    }
}

class FloatingText extends Entity {
    constructor(x, y, text, color) { super(x, y, 0); this.text = text; this.color = color; this.life = 1.0; }
    update() { this.y -= 1; this.life -= 0.02; if(this.life<=0) this.dead=true; }
    draw(ctx) { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.font = "bold 20px 'Fredoka One'"; ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha=1; }
}

class Coin extends Entity {
    constructor(x, y) { super(x, y, 8); }
    update() {
        const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
        if(dist < game.player.magnetRange) {
             const ang = Math.atan2(game.player.y - this.y, game.player.x - this.x); this.x += Math.cos(ang) * 12; this.y += Math.sin(ang) * 12;
             if(dist < 30) { this.dead = true; game.addCoins(1); }
        }
    }
    draw(ctx) { drawCircle(ctx, this.x, this.y, 6, '#f1c40f', '#f39c12'); ctx.fillStyle='#fff'; ctx.font="10px sans-serif"; ctx.fillText("$", this.x-3, this.y+3); }
}

class Particle extends Entity {
    constructor(x, y, col) { super(x, y, 0); this.col = col; this.life = 1.0; this.vx=(Math.random()-0.5)*5; this.vy=(Math.random()-0.5)*5; }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; if(this.life<=0) this.dead=true; }
    draw(ctx) { ctx.globalAlpha=this.life; drawCircle(ctx, this.x, this.y, 4, this.col); ctx.globalAlpha=1; }
}

class Pickup extends Entity {
    constructor(x, y, type) { super(x, y, 15); this.type = type; this.bob = 0; }
    update() { this.bob += 0.1; }
    draw(ctx) {
        const yOff = Math.sin(this.bob) * 5; ctx.save(); ctx.translate(this.x, this.y + yOff); ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; ctx.font = '24px serif';
        let t = 'üì¶'; if(this.type === 'potion') t = '‚ù§Ô∏è'; else if(this.type === 'magnet') t = 'üß≤'; else if(this.type === 'chest') t = 'üëë';
        ctx.fillText(t, -12, 8); ctx.restore();
    }
}

class Game {
    constructor() {
        this.camera = new Camera(); this.projectiles=[]; this.particles=[]; this.enemies=[]; this.obstacles=[]; this.xpOrbs=[]; this.pickups=[]; this.texts=[]; this.coinsList=[]; this.merchants=[]; this.altars=[]; this.buffAltars=[]; this.time=0; this.kills=0; this.coins=0; this.bossTimer=0;
    }
    initWorld() {
        for(let i=0; i<10000; i++) {
            const x = Math.random() * CONFIG.worldSize; const y = Math.random() * CONFIG.worldSize;
            if(Math.hypot(x-CONFIG.worldSize/2, y-CONFIG.worldSize/2) > 500) { this.obstacles.push(new Obstacle(x, y, Math.random()>0.3?'tree':'stone')); }
        }
        for(let i=0; i<20; i++) this.merchants.push(new Merchant());
        this.altars = [new SuperAltar()];
        this.buffAltars = [new BuffAltar('vamp'), new BuffAltar('chrono'), new BuffAltar('titan')];
    }
    start(type) {
        document.getElementById('class-screen').style.display='none'; document.getElementById('ui-layer').style.display='block';
        this.initWorld(); this.player = new Player(type);
        this.camera.x = this.player.x-canvas.width/2; this.camera.y = this.player.y-canvas.height/2;
        this.enemies=[]; this.projectiles=[]; this.xpOrbs=[]; this.pickups=[]; this.texts=[]; this.coinsList=[];
        this.time=0; this.startTime = Date.now(); this.lastBossTime = 0; this.kills=0; this.coins=0; this.state='PLAYING';
        this.updateHUD(); this.loop();
    }
    resetGame() {
        this.state = 'MENU'; document.getElementById('game-over-screen').style.display = 'none'; document.getElementById('ui-layer').style.display = 'none'; document.getElementById('class-screen').style.display = 'flex'; this.enemies = []; this.obstacles = []; this.projectiles = [];
    }
    loop() {
        if(this.state !== 'PLAYING') return;
        requestAnimationFrame(()=>this.loop());
        const now = Date.now(); this.time = (now - this.startTime) / 1000;
        const mins = Math.floor(this.time/60).toString().padStart(2,'0'); const secs = Math.floor(this.time%60).toString().padStart(2,'0'); document.getElementById('game-timer').innerText = `${mins}:${secs}`;
        this.player.update(); this.camera.follow(this.player);
        
        const maxEnemies = 40 + Math.floor(this.time/20);
        if(this.enemies.length < maxEnemies && Math.random() < 0.03) { this.enemies.push(new Enemy(false)); }
        if(this.time > 10 && Math.floor(this.time) % 60 === 0 && Math.floor(this.time) !== this.lastBossTime) { this.lastBossTime = Math.floor(this.time); this.spawnBoss(); }

        this.altars.forEach(a => a.update()); this.buffAltars.forEach(a => a.update());
        [this.projectiles, this.enemies, this.particles, this.xpOrbs, this.coinsList, this.pickups, this.merchants, this.texts].forEach(arr => arr.forEach(e => e.update()));
        this.checkCollisions();
        
        this.projectiles=this.projectiles.filter(x=>!x.dead); this.enemies=this.enemies.filter(x=>!x.dead); this.particles=this.particles.filter(x=>!x.dead); this.xpOrbs=this.xpOrbs.filter(x=>!x.dead); this.coinsList=this.coinsList.filter(x=>!x.dead); this.pickups=this.pickups.filter(x=>!x.dead); this.merchants=this.merchants.filter(x=>!x.dead); this.texts=this.texts.filter(x=>!x.dead);
        this.draw(); this.drawMinimap();
    }
    spawnBoss() { this.enemies.push(new Enemy(true)); this.texts.push(new FloatingText(this.player.x, this.player.y-80, "‚ò†Ô∏è –ë–û–°–° –ü–†–ò–®–ï–õ! ‚ò†Ô∏è", "red")); }
    spawnSuperBoss(x, y) { const boss = new Enemy(false, true, x, y); this.enemies.push(boss); this.texts.push(new FloatingText(x, y-100, "‚ò†Ô∏è –õ–ò–ß –ü–†–û–ë–£–î–ò–õ–°–Ø ‚ò†Ô∏è", "#e056fd")); }
    createExplosion(x, y, r, dmg, color) { for(let i=0; i<10; i++) this.particles.push(new Particle(x + (Math.random()-0.5)*r, y + (Math.random()-0.5)*r, color)); this.enemies.forEach(e => { if(Math.hypot(e.x-x, e.y-y) < r + e.r) this.damageEnemy(e, dmg); }); }
    checkCollisions() {
        this.enemies.forEach(e => {
            const dist = Math.hypot(this.player.x-e.x, this.player.y-e.y); const minDist = this.player.r + e.r;
            if(dist < minDist) {
                const dmg = Math.max(1, 10 - this.player.armor); this.player.hp -= dmg * 0.05;
                const angle = Math.atan2(this.player.y - e.y, this.player.x - e.x); const pushDist = minDist - dist; 
                this.player.x += Math.cos(angle) * pushDist; this.player.y += Math.sin(angle) * pushDist;
                this.updateHUD(); if(this.player.hp<=0) this.gameOver();
            }
        });
        this.projectiles.forEach(p => {
            this.enemies.forEach(e => {
                if(Math.hypot(p.x-e.x, p.y-e.y) < p.r+e.r) {
                    if(p.type === 'dagger_slash' || p.type === 'tea_puddle') { game.damageEnemy(e, p.dmg); }
                    else { this.damageEnemy(e, p.dmg); if(p.type!=='garlic' && p.type!=='bomb' && p.type!=='shard') p.dead=true; }
                }
            });
        });
        this.pickups.forEach(p => { if(Math.hypot(this.player.x-p.x, this.player.y-p.y) < this.player.r+p.r) { this.collectPickup(p); p.dead = true; } });
    }
    damageEnemy(e, rawDmg) {
        const armor = Math.max(0, e.armor - this.player.armorPen); const actualDmg = Math.max(1, rawDmg - armor); e.hp -= actualDmg;
        this.texts.push(new FloatingText(e.x, e.y-e.r, Math.floor(actualDmg), '#fff'));
        if(e.hp<=0 && !e.dead) {
            e.dead = true; this.kills++;
            if(this.player.vampirism && Math.random() < 0.3) { this.player.hp = Math.min(this.player.maxHp, this.player.hp + 1); this.updateHUD(); }
            this.coinsList.push(new Coin(e.x, e.y));
            if(e.isSuperBoss) { this.pickups.push(new Pickup(e.x, e.y, 'chest')); this.player.weapons.forEach(w => { w.stats.dmg *= 5; w.stats.size *= 1.5; }); this.texts.push(new FloatingText(e.x, e.y, "–ë–û–ñ–ï–°–¢–í–ï–ù–ù–ê–Ø –°–ò–õ–ê!", "gold")); }
            else if(e.isBoss) { this.pickups.push(new Pickup(e.x, e.y, 'chest')); }
            else { this.xpOrbs.push(new XPOrb(e.x, e.y, e.xp)); if(Math.random() < 0.02) this.pickups.push(new Pickup(e.x, e.y, Math.random()>0.5?'potion':'magnet')); }
            this.particles.push(new Particle(e.x, e.y, '#fff')); this.updateHUD();
        }
    }
    addXP(v) { this.player.xp+=v; if(this.player.xp >= this.player.xpNext) { this.player.xp -= this.player.xpNext; this.player.lvl++; this.player.xpNext=Math.floor(this.player.xpNext*1.5); this.triggerLevelUp(); } this.updateHUD(); }
    addCoins(v) { this.coins += v; this.updateHUD(); }
    getNearestEnemy(s, r) { let n=null, md=r; this.enemies.forEach(e=>{const d=Math.hypot(s.x-e.x, s.y-e.y); if(d<md){md=d; n=e;}}); return n; }
    updateHUD() {
        document.getElementById('hp-bar').style.width = Math.max(0, (this.player.hp/this.player.maxHp)*100)+'%'; document.getElementById('hp-text').innerText = `${Math.floor(this.player.hp)}/${this.player.maxHp}`;
        document.getElementById('xp-bar').style.width = Math.max(0, (this.player.xp/this.player.xpNext)*100)+'%'; document.getElementById('lvl-text').innerText = `LVL ${this.player.lvl}`;
        document.getElementById('coin-count').innerText = `üí∞ ${this.coins}`; document.getElementById('kill-count').innerText = `üíÄ ${this.kills}`;
    }
    collectPickup(p) {
        const msg = document.getElementById('pickup-msg'); msg.style.opacity = 1; setTimeout(()=>msg.style.opacity=0, 1500);
        if(p.type==='potion') { this.player.hp = Math.min(this.player.maxHp, this.player.hp + 50); msg.innerText="+50 HP"; }
        if(p.type==='magnet') { this.xpOrbs.forEach(o => { o.magnetized = true; }); msg.innerText="–ú–ê–ì–ù–ò–¢!"; }
        if(p.type==='chest') { this.triggerLevelUp(false, true); } this.updateHUD();
    }
    openShop(merchant) {
        if (this.state === 'PAUSED') return; this.state = 'PAUSED'; this.currentMerchant = merchant; 
        const scr = document.getElementById('shop-screen'); const cont = document.getElementById('shop-cards'); document.getElementById('shop-coins').innerText = `–ú–æ–Ω–µ—Ç—ã: ${this.coins}`; cont.innerHTML = ''; scr.style.display = 'flex';
        const items = [ { name: '–õ–µ—á–µ–Ω–∏–µ', cost: 10, icon: '‚ù§Ô∏è', desc: '+50 HP', act:()=>{this.player.hp+=50;} }, { name: '–°–∏–ª–∞', cost: 50, icon: '‚öîÔ∏è', desc: '+10% –£—Ä–æ–Ω–∞', act:()=>{this.player.weapons.forEach(w=>w.stats.dmg=Math.ceil(w.stats.dmg*1.1));} }, { name: '–ë—Ä–æ–Ω—è', cost: 40, icon: 'üõ°Ô∏è', desc: '+2 –ë—Ä–æ–Ω–∏', act:()=>{this.player.armor+=2;} }, { name: '–ü—Ä–æ–±–∏—Ç–∏–µ', cost: 60, icon: 'üèπ', desc: '+5 –ü—Ä–æ–±–∏—Ç–∏—è', act:()=>{this.player.armorPen+=5;} } ];
        items.forEach(i => {
            const el = document.createElement('div'); el.className = 'card'; el.innerHTML = `<span class="card-icon">${i.icon}</span><div class="card-title">${i.name}</div><div class="card-desc">${i.desc}</div><div class="cost-badge">üí∞ ${i.cost}</div>`;
            el.onclick = () => { if(this.coins >= i.cost) { this.coins -= i.cost; i.act(); cont.innerHTML = ''; this.closeShop(true); } }; cont.appendChild(el);
        });
    }
    closeShop(purchased) {
        document.getElementById('shop-screen').style.display = 'none'; this.state = 'PLAYING'; this.startTime = Date.now() - (this.time * 1000); 
        if(purchased && this.currentMerchant) { this.currentMerchant.dead = true; } else { this.player.x += 80; } this.loop();
    }
    triggerLevelUp(isAltar=false, isChest=false) {
        this.state = 'PAUSED'; const scr = document.getElementById('upgrade-screen'); const cont = document.getElementById('upgrade-cards'); cont.innerHTML = ''; scr.style.display = 'flex';
        const pool = [];
        this.player.weapons.forEach(w => { pool.push({ type:'weapon', id:w.id, name:w.name, desc: '–ë–æ–µ–≤–∞—è –ú–æ—â—å', icon:w.icon, stat1: 'dmg', stat2: 'cd' }); pool.push({ type:'weapon', id:w.id, name:w.name, desc: '–ú–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ', icon:w.icon, stat1: 'speed', stat2: 'area' }); });
        if(this.player.weapons.length < 4) {
            const allWeapons = [ { id: 'paw', name: '–õ–∞–ø–∞', desc: '–£—Ä–æ–Ω –∏ –ö–î', type: 'weapon' }, { id: 'yarn', name: '–ö–ª—É–±–æ–∫', desc: '–°–∫–æ—Ä–æ—Å—Ç—å', type: 'weapon' }, { id: 'blizzard', name: '–í—å—é–≥–∞', desc: '–û—Å–∫–æ–ª–∫–∏', type: 'weapon' }, { id: 'tea', name: '–ß–∞–π', desc: '–õ—É–∂–∏', type: 'weapon' }, { id: 'dagger', name: '–ö–æ—Ä—Ç–∏–∫', desc: '–ë–ª–∏–∂–Ω–∏–π', type: 'weapon' }, { id: 'fish', name: '–ö–æ—Å—Ç—å', desc: '–ë—É–º–µ—Ä–∞–Ω–≥', type: 'weapon' }, { id: 'bomb_weapon', name: '–ú—è—Ç–∞', desc: '–í–∑—Ä—ã–≤', type: 'weapon' }, { id: 'shadow_claws', name: '–¢–µ–Ω—å', desc: 'AOE', type: 'weapon' }, { id: 'garlic', name: '–ê—É—Ä–∞', desc: '–ó–æ–Ω–∞', type: 'weapon' } ];
            allWeapons.forEach(w => { if(!this.player.weapons.find(pw => pw.id === w.id)) { w.icon = 'üÜï'; pool.push(w); } });
        }
        const statOpts = [ { id: 'multi', name: '–ú—É–ª—å—Ç–∏', desc: '+1 –°–Ω–∞—Ä—è–¥', type: 'stat', icon: '‚ú®' }, { id: 'pen', name: '–û—Å—Ç—Ä–∏–µ', desc: '+5 –ü—Ä–æ–±–∏—Ç–∏—è', type: 'stat', icon: 'üî™' }, { id: 'heal', name: '–ï–¥–∞', desc: '+–ü–æ–ª–Ω–æ–µ HP', type: 'stat', icon: 'üçó' } ];
        statOpts.forEach(s => pool.push(s));

        for(let i=0; i<3; i++) {
            if(pool.length === 0) break;
            const idx = Math.floor(Math.random() * pool.length); const opt = pool[idx]; pool.splice(idx, 1);
            const isRare = Math.random() < 0.07 || isChest; const el = document.createElement('div'); el.className = 'card' + (isRare ? ' rare' : '') + (isChest ? ' mega' : '');
            let title = opt.name; let desc = opt.desc; let icon = opt.icon || '‚öîÔ∏è'; if(opt.type==='weapon' && !opt.stat1) title += " (NEW!)"; if(isRare) desc = "–î–≤–æ–π–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ!"; if(isChest) desc = "–¢–†–û–ô–ù–ê–Ø –°–ò–õ–ê!";
            el.innerHTML = `<span class="card-icon">${icon}</span><div class="card-title">${title}</div><div class="card-desc">${desc}</div>${isRare?'<div class="rare-badge">RARE</div>':''}`;
            el.onclick = () => {
                if(opt.type === 'stat') { if(opt.id==='multi') this.player.globalCount += (isRare?2:1); if(opt.id==='pen') this.player.armorPen += (isRare?10:5); if(opt.id==='heal') this.player.hp = this.player.maxHp; }
                else { const added = this.player.addWeapon(opt.id, isChest); if(added && !isChest) { const w = this.player.weapons.find(x=>x.id===opt.id); if(w) { if(isRare) w.upgrade(opt.stat1, opt.stat2); else w.upgrade(Math.random()>0.5 ? opt.stat1 : opt.stat2); } } }
                this.player.updateWeaponUI(); scr.style.display = 'none'; this.state = 'PLAYING'; this.startTime = Date.now() - (this.time * 1000); this.loop();
            }; cont.appendChild(el);
        }
    }
    gameOver() { this.state = 'GAMEOVER'; document.getElementById('game-over-screen').style.display='flex'; document.getElementById('ui-layer').style.display='none'; const mins = Math.floor(this.time/60); const secs = Math.floor(this.time%60); document.getElementById('go-stats').innerHTML = `–í—ã–∂–∏—Ç–æ: ${mins}:${secs}<br>–£–±–∏—Ç–æ: ${this.kills}`; }
    draw() {
        ctx.fillStyle = CONFIG.colors.grass; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.save(); ctx.translate(-this.camera.x, -this.camera.y);
        ctx.strokeStyle = '#e74c3c'; ctx.lineWidth=10; ctx.strokeRect(0,0,CONFIG.worldSize,CONFIG.worldSize);
        const cx=this.camera.x, cy=this.camera.y; const sx=Math.floor(cx/50)*50, sy=Math.floor(cy/50)*50;
        ctx.fillStyle = CONFIG.colors.grassDark;
        for(let x=sx; x<cx+canvas.width; x+=50) { for(let y=sy; y<cy+canvas.height; y+=50) { if((x*y)%7 === 0) { ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+5,y-10); ctx.lineTo(x+10,y); ctx.fill(); } } }
        this.altars.forEach(a => a.draw(ctx)); this.buffAltars.forEach(a => a.draw(ctx));
        const list = [ ...this.obstacles.filter(o => o && o.isVisible(cx,cy)), ...this.merchants.filter(m => m.isVisible(cx,cy)), ...this.xpOrbs, ...this.pickups, ...this.coinsList, ...this.projectiles, ...this.enemies.filter(e => e.isVisible(cx,cy)), this.player, ...this.particles, ...this.texts ];
        list.sort((a,b)=>a.y-b.y); list.forEach(e=>e.draw(ctx));
        ctx.restore();
    }
    drawMinimap() {
        miniCtx.clearRect(0, 0, 200, 200); miniCtx.translate(100, 100); 
        const radarScale = 0.05; const radarRadius = 100;
        const drawBlip = (tx, ty, color, size, showArrow) => {
            let dx = (tx - this.player.x) * radarScale; let dy = (ty - this.player.y) * radarScale; const dist = Math.hypot(dx, dy);
            if (dist > radarRadius - 5) {
                if (!showArrow) return; const angle = Math.atan2(dy, dx); dx = Math.cos(angle) * (radarRadius - 10); dy = Math.sin(angle) * (radarRadius - 10);
                miniCtx.fillStyle = color; miniCtx.beginPath(); miniCtx.moveTo(dx + Math.cos(angle)*5, dy + Math.sin(angle)*5); miniCtx.lineTo(dx + Math.cos(angle + 2.5)*8, dy + Math.sin(angle + 2.5)*8); miniCtx.lineTo(dx + Math.cos(angle - 2.5)*8, dy + Math.sin(angle - 2.5)*8); miniCtx.fill(); return;
            }
            miniCtx.fillStyle = color; miniCtx.beginPath(); miniCtx.arc(dx, dy, size, 0, Math.PI*2); miniCtx.fill();
        };
        miniCtx.fillStyle = '#fff'; miniCtx.beginPath(); miniCtx.arc(0, 0, 3, 0, Math.PI*2); miniCtx.fill();
        this.altars.forEach(a => { if(a.active) drawBlip(a.x, a.y, '#e056fd', 6, true); });
        this.buffAltars.forEach(a => { if(a.active) drawBlip(a.x, a.y, a.color, 5, false); });
        this.enemies.forEach(e => { if(e.isBoss || e.isSuperBoss) drawBlip(e.x, e.y, 'red', 5, true); else { let dx = (e.x - this.player.x) * radarScale; let dy = (e.y - this.player.y) * radarScale; if(Math.hypot(dx,dy) < radarRadius) { miniCtx.fillStyle = 'rgba(231, 76, 60, 0.8)'; miniCtx.beginPath(); miniCtx.arc(dx, dy, 2, 0, Math.PI*2); miniCtx.fill(); } } });
        this.merchants.forEach(m => drawBlip(m.x, m.y, '#e67e22', 4, false)); 
        this.pickups.forEach(p => { let dx = (p.x - this.player.x) * radarScale; let dy = (p.y - this.player.y) * radarScale; if(Math.hypot(dx,dy) < radarRadius) { miniCtx.fillStyle = 'yellow'; miniCtx.fillRect(dx-1, dy-1, 3, 3); } });
        this.obstacles.forEach(o => { if(!o) return; let dx = (o.x - this.player.x) * radarScale; let dy = (o.y - this.player.y) * radarScale; if(Math.hypot(dx,dy) < radarRadius) { miniCtx.fillStyle = 'rgba(255,255,255,0.2)'; miniCtx.beginPath(); miniCtx.arc(dx, dy, 1, 0, Math.PI*2); miniCtx.fill(); } });
        miniCtx.setTransform(1, 0, 0, 1, 0, 0); 
    }
}

const game = new Game();
</script>
</body>
</html>